<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자유의지 예측 - 집필 시스템</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        /* 진행률 상태 바 */
        .progress-bar-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 30px;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .progress-info h2 {
            font-size: 18px;
            margin: 0;
            font-weight: 600;
        }

        .progress-stats {
            display: flex;
            gap: 15px;
            font-size: 14px;
        }

        .progress-stat {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 500;
        }

        .progress-bar-wrapper {
            flex: 1;
            max-width: 400px;
            margin: 0 30px;
        }

        .progress-bar-bg {
            background: rgba(255,255,255,0.3);
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-fill {
            background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .progress-percentage {
            font-size: 20px;
            font-weight: 700;
            min-width: 60px;
            text-align: right;
        }

        .container {
            display: flex;
            height: calc(100vh - 54px);
        }

        /* 사이드바 - 목차 */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            flex-shrink: 0;
        }

        .sidebar h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }

        .chapter-tree {
            list-style: none;
        }

        .chapter-item {
            margin: 5px 0;
            position: relative;
        }

        .chapter-item-header {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .toggle-btn {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #666;
            background: transparent;
            border: 1px solid #ccc;
            border-radius: 3px;
            transition: all 0.2s;
            flex-shrink: 0;
            user-select: none;
        }

        .toggle-btn:hover {
            background: #e0e0e0;
            color: #333;
            border-color: #999;
        }

        .toggle-btn.collapsed::before {
            content: '+';
        }

        .toggle-btn.expanded::before {
            content: '−';
        }

        .chapter-link {
            display: block;
            padding: 8px 12px;
            text-decoration: none;
            color: #333;
            border-radius: 5px;
            transition: all 0.2s;
            cursor: pointer;
            font-size: 14px;
            flex: 1;
        }

        .chapter-link:hover {
            background: #f0f0f0;
        }

        .chapter-link.active {
            background: #4CAF50;
            color: white;
        }

        .chapter-link.has-content {
            font-weight: 600;
            color: #4CAF50;
        }

        .chapter-link.has-content.active {
            color: white;
        }

        .sub-chapter {
            margin-left: 25px;
            overflow: hidden;
            max-height: 5000px;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            position: relative;
            border-left: 2px solid #e0e0e0; /* 세로 연결선 */
            padding-left: 15px;
        }

        .sub-chapter.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .sub-sub-chapter {
            margin-left: 25px;
            font-size: 13px;
            overflow: hidden;
            max-height: 5000px;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
            position: relative;
            border-left: 2px solid #e0e0e0; /* 세로 연결선 */
            padding-left: 15px;
        }

        .sub-sub-chapter.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }


        /* 트리 구조 연결선 */
        .sub-chapter > .chapter-item::before,
        .sub-sub-chapter > .chapter-item::before {
            content: '';
            position: absolute;
            left: -15px;
            top: 20px;
            width: 15px;
            height: 2px;
            background: #e0e0e0; /* 가로 연결선 */
        }

        /* 마지막 항목은 세로선을 짧게 */
        .sub-chapter > .chapter-item:last-child::after,
        .sub-sub-chapter > .chapter-item:last-child::after {
            content: '';
            position: absolute;
            left: -17px;
            top: 20px;
            bottom: 0;
            width: 2px;
            background: white; /* 세로선 가리기 */
        }


        /* 메인 콘텐츠 */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
            min-width: 0;
        }

        /* 글쓰기 가이드 패널 */
        .guide-panel {
            width: 350px;
            background: #f9f9f9;
            border-left: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            flex-shrink: 0;
            display: none;
        }

        .guide-panel.active {
            display: block;
        }

        .guide-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4CAF50;
        }

        .guide-header h3 {
            font-size: 18px;
            color: #333;
            margin: 0;
        }

        .guide-content {
            line-height: 1.8;
            font-size: 14px;
            color: #555;
        }

        .guide-content h4 {
            font-size: 16px;
            color: #4CAF50;
            margin: 20px 0 10px 0;
        }

        .guide-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .guide-content li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .guide-loading {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .guide-loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .btn-guide {
            background: #9C27B0;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn-guide:hover {
            background: #7B1FA2;
        }

        .content-header {
            padding: 20px 30px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-header h2 {
            font-size: 22px;
            color: #333;
        }

        .content-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .btn-small {
            padding: 5px 12px;
            font-size: 12px;
            background: #607D8B;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-small:hover {
            background: #546E7A;
        }

        /* 편집기 영역 */
        .editor-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .view-mode {
            line-height: 1.8;
            font-size: 15px;
            color: #333;
        }

        .view-mode h1 {
            font-size: 28px;
            margin: 30px 0 20px 0;
            color: #222;
        }

        .view-mode h2 {
            font-size: 24px;
            margin: 25px 0 15px 0;
            color: #333;
        }

        .view-mode h3 {
            font-size: 20px;
            margin: 20px 0 10px 0;
            color: #444;
        }

        .view-mode p {
            margin: 15px 0;
        }

        .view-mode hr {
            margin: 30px 0;
            border: none;
            border-top: 2px solid #ddd;
        }

        .view-mode img {
            width: 80%;
            height: auto;
            margin: 20px auto;
            display: block;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .view-mode table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        .view-mode table th,
        .view-mode table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .view-mode table th {
            background: #f5f5f5;
            font-weight: 600;
        }

        .toolbar {
            background: #f5f5f5;
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .toolbar button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #f0f0f0;
        }

        /* ========== 개선된 툴바 스타일 ========== */
        .toolbar {
            background: #f5f5f5 !important;
            padding: 8px 10px !important;
            border: 1px solid #e0e0e0 !important;
            flex-wrap: wrap !important;
            align-items: flex-start !important;
            overflow: visible !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
        }

        .toolbar button {
            padding: 4px 8px !important;
            font-size: 11px !important;
            flex-shrink: 1 !important;
            white-space: nowrap !important;
        }

        .toolbar-group {
            display: flex;
            gap: 3px;
            padding: 3px 5px;
            background: #fff;
            border-radius: 4px;
            border-left: 2px solid #ccc;
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 1;
            min-width: 0;
        }

        .toolbar-group-label {
            color: #666 !important;
            font-size: 9px !important;
            padding: 0 5px;
        }

        .toolbar button.btn-image {
            background: #ff9800 !important;
            color: white !important;
            border: 1px solid #ff9800 !important;
        }

        .toolbar button.btn-image:hover {
            background: #f57c00 !important;
            border-color: #f57c00 !important;
        }



        #contentEditor {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 15px;
            line-height: 1.8;
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            resize: vertical;
        }

        .content-editor-editable {
            background: white;
            overflow-y: auto;
            max-height: 600px;
        }

        .content-editor-editable:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }

        .content-editor-editable img {
            width: 80%;
            height: auto;
            margin: 20px auto;
            display: block;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        .content-editor-editable p {
            margin: 10px 0;
        }

        .content-editor-editable h1,
        .content-editor-editable h2,
        .content-editor-editable h3 {
            margin: 20px 0 10px 0;
        }

        .content-editor-editable table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        .content-editor-editable table th,
        .content-editor-editable table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .content-editor-editable table th {
            background: #f5f5f5;
            font-weight: 600;
        }

        #editorWrapper {
            position: relative;
        }

        #dropOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(76, 175, 80, 0.1);
            border: 3px dashed #4CAF50;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }

        .attachments {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        .attachments h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
        }

        .attachment-list {
            list-style: none;
        }

        .attachment-item {
            padding: 10px;
            background: #f9f9f9;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .attachment-item a {
            color: #2196F3;
            text-decoration: none;
        }

        .attachment-item a:hover {
            text-decoration: underline;
        }

        .file-upload-area {
            margin-top: 15px;
            padding: 20px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-area:hover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .empty-state {
            text-align: center;
            padding: 100px 20px;
            color: #999;
        }

        .empty-state h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #999;
        }

        /* 스크롤바 스타일 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #4CAF50;
            color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .status-message.error {
            background: #f44336;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }


        /* ========== Phase 2: 목차 관리 모드 스타일 ========== */
        .toc-manage-btn {
            width: 100%;
            padding: 10px 15px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .toc-manage-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .toc-manage-btn.active {
            background: linear-gradient(135deg, #f44336 0%, #e91e63 100%);
        }

        /* 목차 항목 액션 버튼들 */
        .toc-actions {
            display: none;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            flex-wrap: nowrap;
        }

        .toc-manage-mode .toc-actions {
            display: flex;
            margin-left: 0;
            margin-top: 8px;
            padding-left: 25px; /* 토글 버튼 너비만큼 들여쓰기 */
        }

        /* 목차 관리 모드에서 헤더를 세로로 배치 */
        .toc-manage-mode .chapter-item-header {
            flex-direction: column;
            align-items: flex-start;
        }

        /* 제목과 토글 버튼을 가로로 배치하는 래퍼 */
        .chapter-title-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
        }

        .toc-action-btn {
            width: 24px;
            height: 24px;
            padding: 0;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .toc-action-btn:hover {
            background: #f0f0f0;
            transform: scale(1.1);
        }

        .toc-action-btn.up:hover { background: #e3f2fd; border-color: #2196F3; }
        .toc-action-btn.down:hover { background: #e3f2fd; border-color: #2196F3; }
        .toc-action-btn.left:hover { background: #fff3e0; border-color: #FF9800; }
        .toc-action-btn.right:hover { background: #fff3e0; border-color: #FF9800; }
        .toc-action-btn.edit:hover { background: #e8f5e9; border-color: #4CAF50; }
        .toc-action-btn.delete:hover { background: #ffebee; border-color: #f44336; }
        .toc-action-btn.add:hover { background: #e8f5e9; border-color: #4CAF50; }

        /* 새 챕터 추가 영역 */
        .add-chapter-area {
            display: none;
            background: #f9f9f9;
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .toc-manage-mode .add-chapter-area {
            display: block;
        }

        .add-chapter-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .add-chapter-buttons {
            display: flex;
            gap: 8px;
        }

        .add-chapter-buttons button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-chapter-buttons .btn-add {
            background: #4CAF50;
            color: white;
        }

        .add-chapter-buttons .btn-add:hover {
            background: #45a049;
        }

        .add-chapter-buttons .btn-cancel {
            background: #f0f0f0;
            color: #666;
        }

        .add-chapter-buttons .btn-cancel:hover {
            background: #e0e0e0;
        }


        /* 알림 애니메이션 */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

    </style>
    
    <!-- 모바일 반응형 CSS -->
    <link rel="stylesheet" href="mobile-ui.css">

    <!-- 목차 관리 시스템 -->
    <script src="toc-manager.js"></script>
    
    <!-- 모바일 UI 제어 스크립트 -->
    <script src="mobile-ui.js"></script>
    
    <!-- 음성 → 텍스트 변환 -->
    <script src="voice-to-text.js"></script>



</head>
<body>
    
    <!-- 모바일 헤더 (768px 이하에서만 표시) -->
    <div class="mobile-header">
        <button class="mobile-menu-btn" id="mobileTocBtn" title="목차 열기">
            📋
        </button>
        <div class="mobile-header-title">자유의지 예측</div>
        <button class="mobile-menu-btn" id="mobileGuideBtn" title="가이드 열기">
            📝
        </button>
    </div>

    <!-- 오버레이 (패널 열릴 때 배경) -->
    <div class="slide-overlay" id="slideOverlay"></div>

    <!-- 목차 슬라이드 패널 (왼쪽) -->
    <div class="slide-panel slide-panel-left" id="tocSlidePanel">
        <div class="slide-panel-header">
            <h2>📖 목차</h2>
            <button class="slide-panel-close" id="tocPanelClose">✕</button>
        </div>
        <div class="slide-panel-content" id="tocPanelContent">
            <!-- JavaScript로 목차 내용이 복사됩니다 -->
        </div>
    </div>

    <!-- 가이드 슬라이드 패널 (오른쪽) -->
    <div class="slide-panel slide-panel-right" id="guideSlidePanel">
        <div class="slide-panel-header">
            <h2>📝 글쓰기 가이드</h2>
            <button class="slide-panel-close" id="guidePanelClose">✕</button>
        </div>
        <div class="slide-panel-content" id="guidePanelContent">
            <!-- JavaScript로 가이드 내용이 복사됩니다 -->
        </div>
    </div>

    <!-- 진행률 상태 바 -->
    <div class="progress-bar-container">
        <div class="progress-info">
            <h2>📚 자유의지 예측</h2>
            <div class="progress-stats">
                <span class="progress-stat" id="pagesWritten">0 / 500 페이지</span>
                <span class="progress-stat" id="chaptersCompleted">0 / 0 챕터</span>
                <span class="progress-stat" id="totalChars">0 / 337,500 자</span>
            </div>
        </div>
        <div class="progress-bar-wrapper">
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="progressBarFill" style="width: 0%;">
                    <span id="progressBarText"></span>
                </div>
            </div>
        </div>
        <div class="progress-percentage" id="progressPercentage">0%</div>
    </div>

    <div class="container">
        <!-- 사이드바 - 목차 -->
        <div class="sidebar">
            <h1>📖 자유의지 예측</h1>
            
            <!-- Phase 2: 목차 관리 버튼 -->
            <button id="tocManageBtn" class="toc-manage-btn">
                <span>🛠️ 목차 관리</span>
            </button>
            
            <!-- Phase 2: 새 챕터 추가 영역 -->
            <div class="add-chapter-area" id="addChapterArea">
                <h4 style="margin-bottom: 10px; color: #666; font-size: 13px;">➕ 새 챕터 추가</h4>
                <input type="text" class="add-chapter-input" id="newChapterTitle" placeholder="새 챕터 제목을 입력하세요...">
                <select class="add-chapter-input" id="newChapterParent">
                    <option value="">최상위 레벨로 추가</option>
                    <!-- JavaScript로 동적 생성 -->
                </select>
                <div class="add-chapter-buttons">
                    <button class="btn-add" onclick="addNewChapter()">✓ 추가</button>
                    <button class="btn-cancel" onclick="cancelAddChapter()">✕ 취소</button>
                </div>
            </div>

            <div style="margin-bottom: 15px; text-align: right;">
                <button id="collapseAllBtn" class="btn btn-small" style="font-size: 12px; padding: 5px 12px;">
                    − 모두 접기
                </button>
            </div>
            <ul class="chapter-tree" id="chapterTree">
                <!-- JavaScript로 동적 생성 -->
            </ul>
        </div>

        <!-- 메인 콘텐츠 -->
        <div class="main-content">
            <div class="content-header">
                <h2 id="contentTitle">챕터를 선택해주세요</h2>
                <div class="content-actions" id="contentActions" style="display: none;">
                    <button class="btn btn-secondary" id="editBtn" style="display: none;">수정</button>
                    <button class="btn btn-primary" id="saveBtn" style="display: none;">저장</button>
                    <button class="btn btn-danger" id="cancelBtn" style="display: none;">취소</button>
                </div>
            </div>

            <div class="editor-area" id="editorArea">
                <div class="empty-state">
                    <h3>📝 집필을 시작하세요</h3>
                    <p>왼쪽 목차에서 챕터를 선택하면 내용을 작성하거나 수정할 수 있습니다.</p>
                </div>
            </div>
        </div>

        <!-- 글쓰기 가이드 패널 -->
        <div class="guide-panel" id="guidePanel">
            <div class="guide-header">
                <h3>✍️ 글쓰기 가이드</h3>
                <button class="btn-guide" id="regenerateGuideBtn" onclick="regenerateGuide()">🔄 재가이드 생성</button>
            </div>
            <div class="guide-content" id="guideContent">
                <p style="color: #999; text-align: center; padding: 40px 20px;">챕터를 선택하면 글쓰기 가이드가 표시됩니다.</p>
            </div>
        </div>
    </div>

    <script>
        // API Base URL 설정 (로컬/프로덕션 자동 감지)
        const API_BASE_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000' 
            : window.location.origin;
        
        console.log('🔗 API Base URL:', API_BASE_URL);
        
        // 목차 데이터
        const tableOfContents = {
            "bookInfo": {
                title: "📋 책 기본 정보",
                isSpecial: true
            },
            "prologue": {
                title: "프롤로그: 인류의 숙명, 예측에 대한 갈망",
                children: {
                    "p1": { title: "왜 우리는 예측하려 하는가?" },
                    "p2": { title: "예측의 본능: 생존과 번영을 위한 인류의 역사" },
                    "p3": { title: "예측이 성공했을 때의 보상: 역사 속 사례와 현대 사회의 가치" },
                    "p4": { title: "같은 실수를 반복하는 이유: 예측 불가능성이 주는 좌절과 혼란" },
                    "p5": { title: "예측의 당위성: 더 나은 삶을 위한 필수적인 지혜" },
                    "p6": { title: "예측을 위한 인류의 도구들: 과학기술에서 동양의 지혜까지" },
                    "p7": { title: "시간과 공간을 읽어내는 도구: 시계, 달력, 천문학" },
                    "p8": { title: "자연 현상 예측: 날씨 예측의 역사와 발전" },
                    "p9": { title: "사회 현상 예측: 역사의 반복, 유행의 순환 (패션, 음악)" },
                    "p10": { title: "빅데이터와 AI: 모든 과학기술은 예측을 향한다" },
                    "p11": { title: "예측만을 위한 학문: 동양의 점술과 사주명리" },
                    "p12": { title: "과학기술로 설명할 수 없는 기호와 의지의 문제" },
                    "p13": { title: "결과와 과정: 점술/사주명리가 가진 독특한 설득력" },
                    "p14": { title: "'두루뭉술한' 예측의 오해와 '구체화된' 예측의 정확성" },
                    "p15": { title: "한국, 예측의 특이점: 점술 시장의 비밀" },
                    "p16": { title: "전 세계 인구 대비 압도적인 한국의 점술 시장" },
                    "p17": { title: "한국 점술의 특이성: '과거 해소'보다 '미래 예측'에 집중하는 문화" },
                    "p18": { title: "'신들의 나라' 한국이 점술에 열광하는 이유" },
                    "p19": { title: "점술과 사주명리의 경계, 그리고 '역사주'의 등장" },
                    "p20": { title: "예측 툴로서의 점술과 사주명리의 공통점과 차이점" },
                    "p21": { title: "사주명리: 달력의 원리에 기반한 역학" },
                    "p22": { title: "점술의 두 갈래: 사주명리의 미분(세분화) 개념과 신접(神接)의 세계" },
                    "p23": { title: "비과학적 근거에 대한 비판과 그럼에도 불구하고 믿는 이유" },
                    "p24": { title: "예측률의 한계: 70%와 55%, 믿을 수 없는 예측과 소름 돋는 예측" },
                    "p25": { title: "사주명리, 오래된 기술이 된 이유" },
                    "p26": { title: "반만년 역사 속에서 '원리'보다 '기술'로 전수된 지혜" },
                    "p27": { title: "어설프게 맞지만, 왜 맞는지는 몰랐던 과거의 한계" },
                    "p28": { title: "'비급'과 '비밀': 예측의 가치가 만들어낸 폐쇄성" },
                    "p29": { title: "새로운 예측의 시대: '역사주'의 탄생 배경" },
                    "p30": { title: "과거의 실망을 넘어선 새로운 시도" },
                    "p31": { title: "'오행의 정체'와 '운, 기'의 현대적 재해석" },
                    "p32": { title: "시간과 에너지: '역사주'가 예측의 새로운 지평을 열다" }
                }
            },
            "part1": {
                title: "제1부. '역사주'의 근간: 음양오행, 변화하는 에너지",
                children: {
                    "1-1": {
                        title: "무극에서 음양으로: 모든 것의 시작",
                        children: {
                            "1-1-1": { title: "무극의 상태와 시간의 발생" },
                            "1-1-2": { title: "에너지와 시간: 아인슈타인의 방정식으로 본 관계" },
                            "1-1-3": { title: "음양의 발생: 에너지 차이에 의한 편차" },
                            "1-1-4": { title: "음양에서 오행으로: 에너지의 흐름과 균형" },
                            "1-1-5": { title: "오행의 분화와 에너지 준위" },
                            "1-1-6": { title: "오행의 특성: 목, 화, 토, 금, 수" }
                        }
                    },
                    "1-2": {
                        title: "고정적이지 않은 오행: 불변하지 않고 변화하며 상대적인 오행",
                        children: {
                            "1-2-1": { title: "십간(十干): 변화하는 오행의 표현" },
                            "1-2-2": { title: "천간의 음양과 오행 분류" },
                            "1-2-3": { title: "십간의 물리적/자연적 특징과 대표 물상" }
                        }
                    },
                    "1-3": {
                        title: "오행의 상호작용: 생(生), 극(剋), 충(沖), 합(合)",
                        children: {
                            "1-3-1": { title: "충과 합의 파동적 증명: 보강 간섭과 상쇄 간섭" },
                            "1-3-2": { title: "오행의 합화 현상 (굴절, 역화)" }
                        }
                    },
                    "1-4": {
                        title: "십성(十星): 인간 본연의 욕구와 에너지",
                        children: {
                            "1-4-1": { title: "십성이란 무엇이며, 왜 나타나는가" },
                            "1-4-2": { title: "본원(기준 오행)과 십성: 나와 오행의 관계 (육친)" },
                            "1-4-3": { title: "십성의 원리: 에너지 준위와 심리적/행동적 특성" }
                        }
                    },
                    "1-5": { title: "토체(질량체)를 지나는 십간의 지연 현상: 12지지의 탄생 원리" }
                }
            },
            "part2": {
                title: "제2부. 운과 기: 시간과 에너지의 실체적 발현",
                children: {
                    "2-1": {
                        title: "운(運)과 기(氣)의 명명: 천간과 지지",
                        children: {
                            "2-1-1": { title: "운(천간): 때, 시점, 주기적 변화" },
                            "2-1-2": { title: "기(지지): 기세, 에너지, 힘, 주변 환경의 영향" },
                            "2-1-3": { title: "운기(運氣)의 실제: 천간은 기를 담는 그릇" }
                        }
                    },
                    "2-2": {
                        title: "운기의 자연 현상: 과학적 연결고리",
                        children: {
                            "2-2-1": { title: "원자의 전자 오비탈과 채움 순서" },
                            "2-2-2": { title: "도파민과 도파민 수용체" },
                            "2-2-3": { title: "호르몬과 호르몬 수용체" },
                            "2-2-4": { title: "각종 바이러스와 접촉 수용체" },
                            "2-2-5": { title: "남자와 여자의 성기 모습 차이: 운기와 질량체의 관계" }
                        }
                    },
                    "2-3": {
                        title: "60갑자: 운기의 기본 구성 원리",
                        children: {
                            "2-3-1": { title: "60갑자의 종류와 자체 투간" }
                        }
                    },
                    "2-4": {
                        title: "지지(地支)와 지장간(地藏干): 운기 발현의 깊이",
                        children: {
                            "2-4-1": { title: "12지지의 구성과 지장간의 발현 순서" },
                            "2-4-2": { title: "지장간의 수치: 기의 크기" }
                        }
                    },
                    "2-5": {
                        title: "투간(透干): 지장간의 에너지가 천간으로 발현되는 현상",
                        children: {
                            "2-5-1": { title: "신강(身强)과 신약(身弱)의 재해석" }
                        }
                    },
                    "2-6": {
                        title: "사주팔자: 삶의 운기 구조",
                        children: {
                            "2-6-1": { title: "년월일시 사주의 구성과 의미" },
                            "2-6-2": { title: "사주의 기점: 출생 시점에 정해지는 운기" },
                            "2-6-3": { title: "일상생활에서 사주의 작동 원리 경험" }
                        }
                    },
                    "2-7": {
                        title: "현운(現運): 오늘의 운세와 사주의 상호작용",
                        children: {
                            "2-7-1": { title: "여러 운기의 동시 작용 계산: 음양 삼합론" },
                            "2-7-2": { title: "운기의 작동 모델: 홀덤 게임 비유" }
                        }
                    }
                }
            },
            "part3": {
                title: "제3부. '역사주' 핵심 이론: 본원 이동, 수용운, 합화",
                children: {
                    "3-1": {
                        title: "본원(本源) 이동론: 삶의 변화를 읽는 새로운 기준점",
                        children: {
                            "3-1-1": { title: "근묘화실(根苗花實) 원리부터 시작하는 본원의 변화" },
                            "3-1-2": { title: "본원이동의 시기: 18년 주기와 그 증거" },
                            "3-1-3": { title: "나이가 들수록 죽음에 이르는 과정: 생명은 소용돌이와 같다" }
                        }
                    },
                    "3-2": {
                        title: "수용운(受容運)론: 십간 움직임의 원리",
                        children: {
                            "3-2-1": { title: "음양오행 원리의 세분화" },
                            "3-2-2": { title: "토체(질량체)에 대한 지체 및 복사 현상" },
                            "3-2-3": { title: "이성질체(짝수): 오른쪽 나선만 존재하는 세상" },
                            "3-2-4": { title: "천간의 개수 증가가 운의 감소를 의미하는 이유" },
                            "3-2-5": { title: "지장간의 크기와 운의 크기 및 능력" }
                        }
                    },
                    "3-3": {
                        title: "합화(合化)론: 운기의 로렌츠 나비 곡선",
                        children: {
                            "3-3-1": { title: "오행의 합화: 본래의 오행을 버리고 다른 오행으로 바뀌는 현상" },
                            "3-3-2": { title: "지장간의 크기와 합화: 오운의 나비" },
                            "3-3-3": { title: "로렌츠의 나비 곡선과 합화 현상의 유사성" }
                        }
                    }
                }
            },
            "part4": {
                title: "제4부. '역사주'의 다양한 운: 삶의 에너지를 읽다",
                children: {
                    "4-1": {
                        title: "인체의 운기: 중운(中運)",
                        children: {
                            "4-1-1": { title: "인류 보편의 신체적 특징과 운기 변화의 관계" },
                            "4-1-2": { title: "5년 주기 체중운의 시작과 변화" },
                            "4-1-3": { title: "경락을 통한 운기의 느낌" },
                            "4-1-4": { title: "경락의 생성과 오행 반응" },
                            "4-1-5": { title: "오행별 체질과 특징" },
                            "4-1-6": { title: "오행과 표정: 운기가 감정에 미치는 영향" }
                        }
                    },
                    "4-2": {
                        title: "삶의 큰 흐름: 체장운과 대운",
                        children: {
                            "4-2-1": { title: "대운: 월운의 10년 주기 변화" },
                            "4-2-2": { title: "체대운: 근묘화실의 원리에 의한 18년 주기 변화" },
                            "4-2-3": { title: "에너지 흐름에 따른 차이 인식" }
                        }
                    },
                    "4-3": {
                        title: "현재의 운: 현운(現運)",
                        children: {
                            "4-3-1": { title: "현운: 현재의 년월일시 운기" },
                            "4-3-2": { title: "현운의 다양성과 공통 적용" },
                            "4-3-3": { title: "사주와 현운의 합쳐진 해석의 중요성" }
                        }
                    },
                    "4-4": {
                        title: "장소의 운기: 지운과 장운",
                        children: {
                            "4-4-1": { title: "지운: 지구의 경도별/위도별 오행 설정과 작용" },
                            "4-4-2": { title: "지운의 시기별 변화: 태양의 고도와 에너지 보정" },
                            "4-4-3": { title: "장운: 20년 주기의 운, 풍수지리와 전쟁/정복의 역사" },
                            "4-4-4": { title: "지운의 특징 및 개운법 활용" }
                        }
                    }
                }
            },
            "part5": {
                title: "제5부. '역사주' 예측의 완성: 인생 그래프와 개운 전략",
                children: {
                    "5-1": {
                        title: "인생 그래프의 도출과 기본 해석",
                        children: {
                            "5-1-1": { title: "'역사주' 인생 그래프의 역할" },
                            "5-1-2": { title: "충의 적용과 그래프 해석" },
                            "5-1-3": { title: "십성과 합화로 그래프 보는 방법" }
                        }
                    },
                    "5-2": {
                        title: "예측의 정확성을 높이는 오차 수정",
                        children: {
                            "5-2-1": { title: "균시차와 태양시" },
                            "5-2-2": { title: "달력 오차: 지구 공전일과 윤년의 영향" },
                            "5-2-3": { title: "일, 월, 년이 바뀌는 포인트" },
                            "5-2-4": { title: "운기의 불확실성: 미발견 운기 및 예측의 한계" }
                        }
                    },
                    "5-3": {
                        title: "'역사주' 실전 해석 사례",
                        children: {
                            "5-3-1": { title: "실제 인생 그래프와 사례를 통한 해석 방법" },
                            "5-3-2": { title: "사고 사례 분석: 운기 작용 과정" },
                            "5-3-3": { title: "궁합 사례 분석" }
                        }
                    },
                    "5-4": {
                        title: "'역사주'를 통한 개운 전략",
                        children: {
                            "5-4-1": { title: "운기의 작동 과정: 외부 운, 고유 운, 선택과 의지" },
                            "5-4-2": { title: "운세의 변수 조정" },
                            "5-4-3": { title: "좋은 운의 극대화와 나쁜 운의 회피 전략" },
                            "5-4-4": { title: "결혼, 사업, 취업 등에 운기가 미치는 영향과 활용" }
                        }
                    }
                }
            },
            "epilogue": {
                title: "에필로그: AI 시대, '역사주'와 상생하다",
                children: {
                    "e1": { title: "AI와의 경쟁과 상생: 인간 예측의 가치" },
                    "e2": { title: "'역사주'가 제시하는 삶의 새로운 지도와 통찰" },
                    "e3": { title: "'역사주' 공부의 의미와 활용 방안" },
                    "e4": { title: "'역사주'의 한계와 개운의 가능성" }
                }
            }
        };

        // ✅ window 객체에 할당하여 toc-manager.js에서 접근 가능하도록 설정
        window.tableOfContents = tableOfContents;


        let currentChapterId = null;
        let isEditMode = false;
        let originalContent = '';
        let chapterData = {};

        const TOTAL_PAGES = 500;
        const CHARS_PER_PAGE = 675; // A5 기준, 25행 × 27자 = 675자

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            await loadChapterData();
            renderChapterTree();
            updateProgress();
            
            // 모두 접기/펼치기 버튼 이벤트
            const collapseBtn = document.getElementById('collapseAllBtn');
            let isAllCollapsed = false;
            
            collapseBtn.addEventListener('click', () => {
                const allToggles = document.querySelectorAll('.toggle-btn');
                const allSubLists = document.querySelectorAll('.sub-chapter, .sub-sub-chapter');
                
                if (isAllCollapsed) {
                    // 모두 펼치기
                    allToggles.forEach(btn => {
                        btn.classList.remove('collapsed');
                        btn.classList.add('expanded');
                    });
                    allSubLists.forEach(ul => {
                        ul.classList.remove('collapsed');
                    });
                    collapseBtn.textContent = '− 모두 접기';
                    isAllCollapsed = false;
                } else {
                    // 모두 접기
                    allToggles.forEach(btn => {
                        btn.classList.remove('expanded');
                        btn.classList.add('collapsed');
                    });
                    allSubLists.forEach(ul => {
                        ul.classList.add('collapsed');
                    });
                    collapseBtn.textContent = '+ 모두 펼치기';
                    isAllCollapsed = true;
                }
            });
        });

        // 진행률 계산
        function calculateProgress() {
            let totalChars = 0;
            let completedChapters = 0;
            let totalChapters = 0;

            // 모든 챕터 순회
            function countChapters(obj, prefix = '') {
                Object.keys(obj).forEach(key => {
                    if (key === 'bookInfo') return; // 책 기본 정보는 제외
                    
                    const fullKey = prefix ? `${prefix}-${key}` : key;
                    const item = obj[key];

                    if (item.children) {
                        countChapters(item.children, fullKey);
                    } else {
                        totalChapters++;
                        const data = chapterData[fullKey];
                        if (data && data.content) {
                            // HTML 태그 제거하고 텍스트만 카운트
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = data.content;
                            const textContent = tempDiv.textContent || tempDiv.innerText || '';
                            const chars = textContent.trim().length;
                            
                            if (chars > 0) {
                                totalChars += chars;
                                if (chars >= 100) { // 최소 100자 이상이면 완료로 간주
                                    completedChapters++;
                                }
                            }
                        }
                    }
                });
            }

            countChapters(tableOfContents);

            const pagesWritten = Math.floor(totalChars / CHARS_PER_PAGE);
            const percentage = Math.min(100, (pagesWritten / TOTAL_PAGES) * 100);

            return {
                pagesWritten,
                totalPages: TOTAL_PAGES,
                percentage: percentage.toFixed(1),
                completedChapters,
                totalChapters,
                totalChars
            };
        }

        // 진행률 UI 업데이트
        function updateProgress() {
            const progress = calculateProgress();

            document.getElementById('pagesWritten').textContent = 
                `${progress.pagesWritten} / ${progress.totalPages} 페이지`;
            
            document.getElementById('chaptersCompleted').textContent = 
                `${progress.completedChapters} / ${progress.totalChapters} 챕터`;
            
            // 총 글자수 표시 (천 단위 쉼표 추가)
            document.getElementById('totalChars').textContent = 
                `${progress.totalChars.toLocaleString()} / 337,500 자`;
            
            document.getElementById('progressPercentage').textContent = 
                `${progress.percentage}%`;
            
            const fillElement = document.getElementById('progressBarFill');
            fillElement.style.width = `${progress.percentage}%`;
            
            // 진행률에 따른 색상 변경
            const percentage = parseFloat(progress.percentage);
            let gradientColor;
            if (percentage < 30) {
                gradientColor = 'linear-gradient(90deg, #f44336 0%, #e91e63 100%)'; // 빨강
            } else if (percentage < 70) {
                gradientColor = 'linear-gradient(90deg, #FF9800 0%, #FFC107 100%)'; // 노랑
            } else {
                gradientColor = 'linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%)'; // 초록
            }
            fillElement.style.background = gradientColor;
            
            if (progress.percentage > 5) {
                document.getElementById('progressBarText').textContent = 
                    `${progress.percentage}%`;
            } else {
                document.getElementById('progressBarText').textContent = '';
            }
        }

        // 챕터 데이터 로드
        async function loadChapterData() {
            try {
                const response = await fetch('/api/chapters');
                chapterData = await response.json();
            } catch (error) {
                console.error('데이터 로드 실패:', error);
                showMessage('데이터를 불러오는데 실패했습니다.', true);
            }
        }

        // 목차 트리 렌더링
        function renderChapterTree() {
            // 챕터 맵 빌드 (목차 렌더링 전에 항상 맵 갱신)
            buildChapterMap();
            const treeElement = document.getElementById('chapterTree');
            treeElement.innerHTML = '';

            Object.keys(tableOfContents).forEach(key => {
                const chapter = tableOfContents[key];
                const li = document.createElement('li');
                li.className = 'chapter-item';

                // 헤더 컨테이너 생성
                const header = document.createElement('div');
                header.className = 'chapter-item-header';

                // 자식이 있으면 토글 버튼 추가
                if (chapter.children) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn expanded';
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleChapter(toggleBtn);
                    };
                    header.appendChild(toggleBtn);
                }

                const link = document.createElement('a');
                link.className = 'chapter-link' + (chapterData[key]?.content ? ' has-content' : '');
                link.textContent = chapter.title;
                link.setAttribute('data-id', key);
                link.onclick = () => selectChapter(key);

                header.appendChild(link);
                li.appendChild(header);

                if (chapter.children) {
                    const subUl = document.createElement('ul');
                    subUl.className = 'chapter-tree sub-chapter';
                    renderSubChapters(chapter.children, subUl, key);
                    li.appendChild(subUl);
                }

                treeElement.appendChild(li);
            });
            
            // 모바일 목차 업데이트
            if (window.mobileUI && window.mobileUI.isInitialized) {
                setTimeout(() => window.mobileUI.refreshTocContent(), 100);
            }

        }

        // 하위 챕터 렌더링
        function renderSubChapters(children, parentElement, prefix) {
            Object.keys(children).forEach(key => {
                const child = children[key];
                const fullKey = prefix + '-' + key;
                
                const li = document.createElement('li');
                li.className = 'chapter-item';

                // 헤더 컨테이너 생성
                const header = document.createElement('div');
                header.className = 'chapter-item-header';

                // 자식이 있으면 토글 버튼 추가
                if (child.children) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn expanded';
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleChapter(toggleBtn);
                    };
                    header.appendChild(toggleBtn);
                }

                const link = document.createElement('a');
                link.className = 'chapter-link' + (chapterData[fullKey]?.content ? ' has-content' : '');
                link.textContent = child.title;
                link.setAttribute('data-id', fullKey);
                link.onclick = () => selectChapter(fullKey);

                header.appendChild(link);
                li.appendChild(header);

                if (child.children) {
                    const subUl = document.createElement('ul');
                    subUl.className = 'chapter-tree sub-sub-chapter';
                    renderSubChapters(child.children, subUl, fullKey);
                    li.appendChild(subUl);
                }

                parentElement.appendChild(li);
            });
        }

        // 챕터 토글 (접기/펼치기)
        function toggleChapter(button) {
            const li = button.closest('.chapter-item');
            const subList = li.querySelector('ul');
            
            if (!subList) return;

            if (button.classList.contains('expanded')) {
                // 접기
                button.classList.remove('expanded');
                button.classList.add('collapsed');
                subList.classList.add('collapsed');
            } else {
                // 펼치기
                button.classList.remove('collapsed');
                button.classList.add('expanded');
                subList.classList.remove('collapsed');
            }
        }

        // 챕터 선택
        async function selectChapter(chapterId) {
            if (isEditMode && currentChapterId !== chapterId) {
                if (!confirm('저장하지 않은 내용이 있습니다. 계속하시겠습니까?')) {
                    return;
                }
            }

            currentChapterId = chapterId;
            
            // 모든 링크에서 active 제거
            document.querySelectorAll('.chapter-link').forEach(link => {
                link.classList.remove('active');
            });

            // 현재 링크에 active 추가
            event.target.classList.add('active');

            // 챕터 데이터 로드
            await loadChapterContent(chapterId);
            
            // 가이드 패널 표시 및 가이드 생성
            showGuidePanel();
            await generateGuide(chapterId);
        }

        // 챕터 내용 로드
        async function loadChapterContent(chapterId) {
            try {
                const response = await fetch(`/api/chapters/${chapterId}`);
                const data = await response.json();

                const title = getChapterTitle(chapterId);
                document.getElementById('contentTitle').textContent = title;
                document.getElementById('contentActions').style.display = 'flex';

                if (data.content) {
                    // 내용이 있으면 뷰 모드로 표시
                    renderViewMode(data);
                } else {
                    // 내용이 없으면 바로 편집 모드
                    enterEditMode({ content: '', attachments: [] });
                }
            } catch (error) {
                console.error('챕터 로드 실패:', error);
                showMessage('챕터를 불러오는데 실패했습니다.', true);
            }
        }

        // 챕터 맵 (ID → Chapter 객체) 생성
        let chapterMap = {};
        
        function buildChapterMap() {
            chapterMap = {};
            
            function traverse(obj, prefix = '') {
                Object.keys(obj).forEach(key => {
                    const chapter = obj[key];
                    const fullId = prefix ? `${prefix}-${key}` : key;
                    
                    // 맵에 추가
                    chapterMap[fullId] = {
                        title: chapter.title,
                        isSpecial: chapter.isSpecial,
                        children: chapter.children
                    };
                    
                    // 자식이 있으면 재귀 탐색
                    if (chapter.children) {
                        traverse(chapter.children, fullId);
                    }
                });
            }
            
            traverse(tableOfContents);
            console.log('📋 챕터 맵 생성 완료:', Object.keys(chapterMap).length, '개');
        }
        
        // 챕터 제목 가져오기 (맵 방식)
        function getChapterTitle(chapterId) {
            if (!chapterId) return '';
            
            // 맵이 비어있으면 빌드
            if (Object.keys(chapterMap).length === 0) {
                buildChapterMap();
            }
            
            const chapter = chapterMap[chapterId];
            if (chapter) {
                return chapter.title || '';
            }
            
            console.warn(`⚠️ 챕터를 찾을 수 없음: ${chapterId}`);
            return '';
        }

        // 뷰 모드 렌더링
        function renderViewMode(data) {
            isEditMode = false;
            document.getElementById('editBtn').style.display = 'inline-block';
            document.getElementById('saveBtn').style.display = 'none';
            document.getElementById('cancelBtn').style.display = 'none';

            const editorArea = document.getElementById('editorArea');
            editorArea.innerHTML = `
                <div class="view-mode">
                    ${data.content}
                </div>
                ${renderAttachments(data.attachments || [], false)}
            `;
        }

        // 편집 모드 진입
        function enterEditMode(data) {
            console.log('🟡 enterEditMode 호출됨');
            console.log('  - currentChapterId:', currentChapterId);

            isEditMode = true;
            originalContent = data.content;

            document.getElementById('editBtn').style.display = 'none';
            document.getElementById('saveBtn').style.display = 'inline-block';
            document.getElementById('cancelBtn').style.display = 'inline-block';

            // 제목 편집 필드 생성 (toc-manager.js)
            let titleEditorHTML = '';
            if (window.TOCManager && typeof window.TOCManager.createTitleEditorHTML === 'function') {
                titleEditorHTML = window.TOCManager.createTitleEditorHTML(currentChapterId);
                console.log('  - 제목 편집 필드 생성됨');
            } else {
                console.warn('⚠️ TOCManager.createTitleEditorHTML를 찾을 수 없습니다!');
            }

            const editorArea = document.getElementById('editorArea');
            editorArea.innerHTML = `
                ${titleEditorHTML}
                <div class="toolbar">
                    <!-- 텍스트 스타일 그룹 -->
                    <div class="toolbar-group">
                        <span class="toolbar-group-label">📝 텍스트</span>
                        <button onclick="insertFormat('p')" title="본문">본문</button>
                        <button onclick="insertFormat('h1')" title="제목 1">제목 1</button>
                        <button onclick="insertFormat('h2')" title="제목 2">제목 2</button>
                        <button onclick="insertFormat('h3')" title="제목 3">제목 3</button>
                    </div>

                    <!-- 서식 그룹 -->
                    <div class="toolbar-group">
                        <span class="toolbar-group-label">✏️ 서식</span>
                        <button onclick="insertFormat('bold')" title="굵게"><strong>B</strong></button>
                        <button onclick="insertFormat('italic')" title="기울임"><em>I</em></button>
                        <button onclick="insertFormat('underline')" title="밑줄"><u>U</u></button>
                    </div>

                    <!-- 구분선 그룹 -->
                    <div class="toolbar-group">
                        <span class="toolbar-group-label">➖ 구분선</span>
                        <button onclick="insertFormat('hr-solid')" title="실선">━━━</button>
                        <button onclick="insertFormat('hr-dashed')" title="점선">┈┈┈</button>
                    </div>

                    <!-- 삽입 그룹 -->
                    <div class="toolbar-group">
                        <span class="toolbar-group-label">📊 삽입</span>
                        <button onclick="insertTableWithSize()" title="표 삽입">📊 표</button>
                        <button onclick="document.getElementById('imageInput').click()" class="btn-image" title="이미지 삽입">🖼️ 이미지</button>
                        <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="insertImage(this)">
                    </div>
                </div>
                <div id="contentEditor" contenteditable="true" class="content-editor-editable">${data.content || '<p>내용을 입력하세요...</p>'}</div>
                ${renderAttachments(data.attachments || [], true)}
            `;

            console.log('✅ 편집 모드 UI 생성 완료');
            // 드래그드롭 제거됨 (사용자 요청)
        }

        // 드래그 앤 드롭 설정
        function setupDragAndDrop() {
            const editor = document.getElementById('contentEditor');
            const overlay = document.getElementById('dropOverlay');
            let dragCounter = 0;

            editor.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter++;
                if (overlay) {
                    overlay.style.display = 'flex';
                }
            });

            editor.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter--;
                if (dragCounter === 0 && overlay) {
                    overlay.style.display = 'none';
                }
            });

            editor.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            editor.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter = 0;
                if (overlay) {
                    overlay.style.display = 'none';
                }

                const files = e.dataTransfer.files;
                if (files.length === 0) return;

                // 이미지 파일만 필터링
                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                
                if (imageFiles.length === 0) {
                    showMessage('이미지 파일만 드롭할 수 있습니다.', true);
                    return;
                }

                // 각 이미지 업로드 및 삽입
                for (const file of imageFiles) {
                    await uploadAndInsertImageAtCursor(file);
                }
            });
        }

        // 커서 위치에 이미지 삽입
        async function uploadAndInsertImageAtCursor(file) {
            showMessage('이미지를 업로드 중입니다...');

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    const editor = document.getElementById('contentEditor');
                    const imageHTML = `<br><br><img src="${result.path}" alt="${result.originalname}" style="width: 80%; height: auto; margin: 20px auto; display: block;"><br><br>`;
                    
                    if (editor.contentEditable === 'true') {
                        // contenteditable의 경우 현재 커서 위치에 삽입
                        editor.focus();
                        document.execCommand('insertHTML', false, imageHTML);
                    } else {
                        // textarea의 경우 (하위 호환성)
                        const cursorPos = editor.selectionStart;
                        editor.value = editor.value.substring(0, cursorPos) + imageHTML + editor.value.substring(cursorPos);
                        editor.focus();
                        editor.selectionStart = editor.selectionEnd = cursorPos + imageHTML.length;
                    }
                    
                    showMessage('이미지가 삽입되었습니다.');
                    return true;
                } else {
                    showMessage('이미지 업로드에 실패했습니다.', true);
                    return false;
                }
            } catch (error) {
                console.error('이미지 업로드 실패:', error);
                showMessage('이미지 업로드에 실패했습니다.', true);
                return false;
            }
        }

        // 이미지 업로드 및 삽입 (공통 함수)
        async function uploadAndInsertImage(file, cursorPos) {
            showMessage('이미지를 업로드 중입니다...');

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    const editor = document.getElementById('contentEditor');
                    // 줄바꿈 2개씩 추가하여 이미지 앞뒤로 여백 생성, 가로 80%로 설정
                    const imageTag = `<br><br><img src="${result.path}" alt="${result.originalname}" style="width: 80%; height: auto; margin: 20px auto; display: block;"><br><br>`;
                    
                    // contenteditable div인 경우
                    if (editor.contentEditable === 'true') {
                        const imgElement = document.createElement('div');
                        imgElement.innerHTML = imageTag;
                        
                        // 현재 선택 영역에 삽입
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.deleteContents();
                            range.insertNode(imgElement.firstChild);
                        }
                    } else {
                        // textarea인 경우 (하위 호환성)
                        editor.value = editor.value.substring(0, cursorPos) + imageTag + editor.value.substring(cursorPos);
                        editor.focus();
                        editor.selectionStart = editor.selectionEnd = cursorPos + imageTag.length;
                    }
                    
                    showMessage('이미지가 삽입되었습니다.');
                    return true;
                } else {
                    showMessage('이미지 업로드에 실패했습니다.', true);
                    return false;
                }
            } catch (error) {
                console.error('이미지 업로드 실패:', error);
                showMessage('이미지 업로드에 실패했습니다.', true);
                return false;
            }
        }


        // 표 크기 입력받아 삽입
        function insertTableWithSize() {
            const rows = prompt('행(세로) 개수를 입력하세요:', '3');
            const cols = prompt('열(가로) 개수를 입력하세요:', '3');
            
            if (rows === null || cols === null) return; // 취소
            
            const numRows = parseInt(rows);
            const numCols = parseInt(cols);
            
            if (isNaN(numRows) || isNaN(numCols) || numRows < 1 || numCols < 1) {
                alert('올바른 숫자를 입력해주세요.');
                return;
            }
            
            if (numRows > 20 || numCols > 10) {
                alert('표가 너무 큽니다. 행은 최대 20개, 열은 최대 10개까지 가능합니다.');
                return;
            }
            
            let tableHTML = '<table>\n';
            
            // 헤더 행
            tableHTML += '  <tr>\n';
            for (let j = 1; j <= numCols; j++) {
                tableHTML += `    <th>헤더${j}</th>\n`;
            }
            tableHTML += '  </tr>\n';
            
            // 데이터 행들
            for (let i = 1; i < numRows; i++) {
                tableHTML += '  <tr>\n';
                for (let j = 1; j <= numCols; j++) {
                    tableHTML += `    <td>데이터${i}-${j}</td>\n`;
                }
                tableHTML += '  </tr>\n';
            }
            
            tableHTML += '</table><br>';
            
            const editor = document.getElementById('contentEditor');
            if (editor) {
                editor.focus();
                document.execCommand('insertHTML', false, tableHTML);
            }
        }

        // 서식 삽입
        function insertFormat(type) {
            const editor = document.getElementById('contentEditor');
            
            // contenteditable div인 경우
            if (editor.contentEditable === 'true') {
                editor.focus();
                
                switch(type) {
                    case 'h1':
                        document.execCommand('formatBlock', false, '<h1>');
                        break;
                    case 'h2':
                        document.execCommand('formatBlock', false, '<h2>');
                        break;
                    case 'h3':
                        document.execCommand('formatBlock', false, '<h3>');
                        break;
                    case 'hr':
                        document.execCommand('insertHTML', false, '<hr>');
                        break;
                    case 'table':
                        const tableHTML = `<table>
    <tr>
        <th>헤더1</th>
        <th>헤더2</th>
        <th>헤더3</th>
    </tr>
    <tr>
        <td>데이터1</td>
        <td>데이터2</td>
        <td>데이터3</td>
    </tr>
</table><br>`;
                        document.execCommand('insertHTML', false, tableHTML);
                        break;
                    case 'bold':
                        document.execCommand('bold', false, null);
                        break;
                    case 'italic':
                        document.execCommand('italic', false, null);
                        break;
                    case 'underline':
                        document.execCommand('underline', false, null);
                        break;
                    case 'p':
                        document.execCommand('formatBlock', false, '<p>');
                        break;
                    case 'hr-solid':
                        document.execCommand('insertHTML', false, '<hr style="border: none; border-top: 2px solid #999; margin: 20px 0;"><p></p>');
                        break;
                    case 'hr-dashed':
                        document.execCommand('insertHTML', false, '<hr style="border: none; border-top: 2px dashed #999; margin: 20px 0;"><p></p>');
                        break;
                }
            } else {
                // textarea인 경우 (하위 호환성)
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const selectedText = editor.value.substring(start, end);
                let insertText = '';

                switch(type) {
                    case 'h1':
                        insertText = `<h1>${selectedText || '제목을 입력하세요'}</h1>\n`;
                        break;
                    case 'h2':
                        insertText = `<h2>${selectedText || '제목을 입력하세요'}</h2>\n`;
                        break;
                    case 'h3':
                        insertText = `<h3>${selectedText || '제목을 입력하세요'}</h3>\n`;
                        break;
                    case 'hr':
                        insertText = '<hr>\n';
                        break;
                    case 'table':
                        insertText = `<table>
    <tr>
        <th>헤더1</th>
        <th>헤더2</th>
        <th>헤더3</th>
    </tr>
    <tr>
        <td>데이터1</td>
        <td>데이터2</td>
        <td>데이터3</td>
    </tr>
</table>\n`;
                        break;
                    case 'bold':
                        insertText = `<strong>${selectedText || '굵게'}</strong>`;
                        break;
                    case 'italic':
                        insertText = `<em>${selectedText || '기울임'}</em>`;
                        break;
                }

                editor.value = editor.value.substring(0, start) + insertText + editor.value.substring(end);
                editor.focus();
            }
        }

        // 첨부파일 렌더링
        function renderAttachments(attachments, editMode) {
            if (!attachments || attachments.length === 0) {
                if (!editMode) return '';
            }

            let html = '<div class="attachments"><h3>📎 첨부파일</h3>';
            
            if (attachments.length > 0) {
                html += '<ul class="attachment-list">';
                attachments.forEach((file, index) => {
                    html += `
                        <li class="attachment-item">
                            <a href="${file.path}" target="_blank">${file.originalname}</a>
                            ${editMode ? `<button class="btn btn-danger" onclick="removeAttachment(${index})">삭제</button>` : ''}
                        </li>
                    `;
                });
                html += '</ul>';
            }

            if (editMode) {
                html += `
                    <div class="file-upload-area" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" onchange="uploadFile(this)" multiple>
                        <p>📁 파일을 선택하거나 여기에 드롭하세요</p>
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

        // 이미지 삽입 (버튼 클릭)
        async function insertImage(input) {
            if (!input.files || input.files.length === 0) return;

            const file = input.files[0];
            
            // 이미지 파일인지 확인
            if (!file.type.startsWith('image/')) {
                showMessage('이미지 파일만 삽입할 수 있습니다.', true);
                input.value = '';
                return;
            }

            await uploadAndInsertImageAtCursor(file);
            input.value = '';
        }

        // 파일 업로드 (첨부파일용)
        async function uploadFile(input) {
            if (!input.files || input.files.length === 0) return;

            const formData = new FormData();
            formData.append('file', input.files[0]);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    showMessage('파일이 업로드되었습니다.');
                    
                    // 현재 챕터 데이터에 첨부파일 추가
                    const data = await fetch(`/api/chapters/${currentChapterId}`).then(r => r.json());
                    if (!data.attachments) data.attachments = [];
                    data.attachments.push({
                        filename: result.filename,
                        originalname: result.originalname,
                        path: result.path
                    });

                    // UI 업데이트
                    enterEditMode(data);
                } else {
                    showMessage('파일 업로드에 실패했습니다.', true);
                }
            } catch (error) {
                console.error('파일 업로드 실패:', error);
                showMessage('파일 업로드에 실패했습니다.', true);
            }

            input.value = '';
        }

        // 첨부파일 삭제
        function removeAttachment(index) {
            if (!confirm('이 파일을 삭제하시겠습니까?')) return;

            // 현재 데이터에서 첨부파일 제거
            fetch(`/api/chapters/${currentChapterId}`)
                .then(r => r.json())
                .then(data => {
                    data.attachments.splice(index, 1);
                    enterEditMode(data);
                    showMessage('파일이 삭제되었습니다.');
                });
        }

        // 저장
        async function saveContent() {
            console.log('🔵 saveContent 함수 호출됨');
            console.log('  - currentChapterId:', currentChapterId);

            const editor = document.getElementById('contentEditor');
            console.log('  - editor 존재:', !!editor);

            if (!editor) {
                console.error('❌ contentEditor를 찾을 수 없습니다!');
                showMessage('편집기를 찾을 수 없습니다.', true);
                return;
            }

            // contenteditable div인 경우 innerHTML, textarea인 경우 value 사용
            const content = editor.contentEditable === 'true' ? editor.innerHTML : editor.value;
            console.log('  - content 길이:', content?.length || 0);

            // 1. 챕터 제목 저장 (toc-manager.js)
            console.log('🔵 제목 저장 시도...');
            if (window.TOCManager && typeof window.TOCManager.saveChapterTitle === 'function') {
                const titleSaved = window.TOCManager.saveChapterTitle(currentChapterId);
                console.log('  - 제목 저장 결과:', titleSaved);
            } else {
                console.warn('⚠️ TOCManager.saveChapterTitle를 찾을 수 없습니다!');
            }

            console.log('🔵 챕터 데이터 조회 중...');
            const response = await fetch(`/api/chapters/${currentChapterId}`);
            const currentData = await response.json();
            console.log('  - 현재 데이터:', currentData);

            try {
                console.log('🔵 서버에 저장 요청 중...');
                const saveResponse = await fetch(`/api/chapters/${currentChapterId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: content,
                        attachments: currentData.attachments || []
                    })
                });

                const result = await saveResponse.json();
                console.log('  - 서버 응답:', result);

                if (result.success) {
                    console.log('✅ 저장 성공!');
                    showMessage('저장되었습니다.');
                    await loadChapterData();
                    renderChapterTree();
                    await loadChapterContent(currentChapterId);
                } else {
                    console.error('❌ 저장 실패:', result);
                    showMessage('저장에 실패했습니다.', true);
                }
            } catch (error) {
                console.error('❌ 저장 중 오류:', error);
                showMessage('저장에 실패했습니다.', true);
            }
        }

        // 취소
        function cancelEdit() {
            if (confirm('변경사항을 취소하시겠습니까?')) {
                loadChapterContent(currentChapterId);
            }
        }

        // 메시지 표시
        function showMessage(message, isError = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'status-message' + (isError ? ' error' : '');
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        // 가이드 패널 표시
        function showGuidePanel() {
            document.getElementById('guidePanel').classList.add('active');
        }

        // 가이드 생성
        async function generateGuide(chapterId, existingContent = '') {
            const guideContent = document.getElementById('guideContent');
            guideContent.innerHTML = '<div class="guide-loading">AI가 글쓰기 가이드를 생성하고 있습니다</div>';

            try {
                const title = getChapterTitle(chapterId);
                const bookContext = `
도서 제목: 자유의지 예측
도서 주제: 명리 이론에 대한 새로운 접근 방법 (역사주)
타겟 독자: 45-60세, 25-30세 독자
문체: 전문성과 진중함을 유지하면서도 이해하기 쉬운 비문학 스타일
`;

                // 전체 목차를 읽기 쉬운 텍스트로 변환
                const tocText = generateTableOfContentsText();

                const response = await fetch('/api/generate-guide', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: title,
                        existingContent: existingContent,
                        bookContext: bookContext,
                        tableOfContents: tocText,
                        currentChapterId: chapterId
                    })
                });

                const data = await response.json();
                
                if (data.success && data.guide) {
                    guideContent.innerHTML = data.guide;
                } else {
                    guideContent.innerHTML = `<p style="color: #f44336;">가이드 생성에 실패했습니다.</p>
                    <p style="font-size: 12px; color: #999; margin-top: 10px;">
                        ※ AI 가이드 기능을 사용하려면 Anthropic API 키가 필요합니다.<br>
                        서버 실행 시 환경변수 ANTHROPIC_API_KEY를 설정해주세요.<br>
                        자세한 내용은 API_KEY_SETUP.md 파일을 참고하세요.
                    </p>`;
                }
            } catch (error) {
                console.error('가이드 생성 실패:', error);
                guideContent.innerHTML = `<p style="color: #f44336;">가이드 생성 중 오류가 발생했습니다.</p>
                <p style="font-size: 12px; color: #999; margin-top: 10px;">
                    서버 연결을 확인해주세요.
                </p>`;
            }
        }

        // 전체 목차를 텍스트로 변환
        function generateTableOfContentsText() {
            let text = '';
            
            Object.keys(tableOfContents).forEach(key => {
                const chapter = tableOfContents[key];
                text += `\n${chapter.title}\n`;
                
                if (chapter.children) {
                    Object.keys(chapter.children).forEach(subKey => {
                        const subChapter = chapter.children[subKey];
                        text += `  - ${subChapter.title}\n`;
                        
                        if (subChapter.children) {
                            Object.keys(subChapter.children).forEach(subSubKey => {
                                const subSubChapter = subChapter.children[subSubKey];
                                text += `    • ${subSubChapter.title}\n`;
                            });
                        }
                    });
                }
            });
            
            return text;
        }

        // 재가이드 생성
        async function regenerateGuide() {
            if (!currentChapterId) {
                showMessage('챕터를 먼저 선택해주세요.', true);
                return;
            }

            const editor = document.getElementById('contentEditor');
            let currentContent = '';
            
            if (editor) {
                // 편집 모드인 경우
                currentContent = editor.contentEditable === 'true' ? editor.innerHTML : editor.value;
            } else {
                // 뷰 모드인 경우 - 저장된 내용 가져오기
                try {
                    const response = await fetch(`/api/chapters/${currentChapterId}`);
                    const data = await response.json();
                    currentContent = data.content || '';
                } catch (error) {
                    console.error('내용 로드 실패:', error);
                }
            }

            // HTML 태그 제거하여 순수 텍스트만 추출 (분석용)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentContent;
            const textContent = tempDiv.textContent || tempDiv.innerText || '';

            // 내용이 있든 없든 가이드 생성
            // 내용이 있으면: 내용 분석 + 보충/수정 제안
            // 내용이 없으면: 목차 기반 작성 가이드
            if (textContent.trim().length > 0) {
                showMessage('작성된 내용을 분석하여 재가이드를 생성하고 있습니다...');
            } else {
                showMessage('챕터 제목과 목차를 기반으로 가이드를 생성하고 있습니다...');
            }
            
            await generateGuide(currentChapterId, textContent.trim());
        }

        // 버튼 이벤트 리스너
        document.getElementById('editBtn').addEventListener('click', async () => {
            const response = await fetch(`/api/chapters/${currentChapterId}`);
            const data = await response.json();
            enterEditMode(data);
        });

        document.getElementById('saveBtn').addEventListener('click', function() {
            console.log('🟢 저장 버튼 클릭됨!');
            saveContent();
        });

        document.getElementById('cancelBtn').addEventListener('click', cancelEdit);


        // ========== Phase 2: 목차 관리 시스템 ==========
        
        let isTocManageMode = false;

        // 목차 관리 모드 토글
        document.getElementById('tocManageBtn').addEventListener('click', () => {
            isTocManageMode = !isTocManageMode;
            const sidebar = document.querySelector('.sidebar');
            const btn = document.getElementById('tocManageBtn');
            
            if (isTocManageMode) {
                sidebar.classList.add('toc-manage-mode');
                btn.classList.add('active');
                btn.innerHTML = '<span>✖️ 관리 모드 종료</span>';
                renderChapterTreeWithActions();
                populateParentSelect();
            } else {
                sidebar.classList.remove('toc-manage-mode');
                btn.classList.remove('active');
                btn.innerHTML = '<span>🛠️ 목차 관리</span>';
                renderChapterTree();
            }
        });

        // 액션 버튼이 포함된 목차 트리 렌더링
        function renderChapterTreeWithActions() {
            const treeElement = document.getElementById('chapterTree');
            treeElement.innerHTML = '';

            Object.keys(tableOfContents).forEach((key, index) => {
                const chapter = tableOfContents[key];
                const li = document.createElement('li');
                li.className = 'chapter-item';
                li.dataset.chapterId = key;

                const header = document.createElement('div');
                header.className = 'chapter-item-header';

                // 제목 영역 (토글 버튼 + 링크)
                const titleWrapper = document.createElement('div');
                titleWrapper.className = 'chapter-title-wrapper';

                // 토글 버튼
                if (chapter.children) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn expanded';
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleChapter(toggleBtn);
                    };
                    titleWrapper.appendChild(toggleBtn);
                }

                // 챕터 링크
                const link = document.createElement('a');
                link.className = 'chapter-link' + (chapterData[key]?.content ? ' has-content' : '');
                link.textContent = chapter.title;
                link.setAttribute('data-id', key);
                link.onclick = () => selectChapter(key);
                titleWrapper.appendChild(link);

                header.appendChild(titleWrapper);

                // 액션 버튼들
                const actions = document.createElement('div');
                actions.className = 'toc-actions';
                
                // 위로 이동
                if (index > 0) {
                    const upBtn = document.createElement('button');
                    upBtn.className = 'toc-action-btn up';
                    upBtn.innerHTML = '↑';
                    upBtn.title = '위로 이동';
                    upBtn.onclick = (e) => {
                        e.stopPropagation();
                        moveChapterUp(key);
                    };
                    actions.appendChild(upBtn);
                }

                // 아래로 이동
                if (index < Object.keys(tableOfContents).length - 1) {
                    const downBtn = document.createElement('button');
                    downBtn.className = 'toc-action-btn down';
                    downBtn.innerHTML = '↓';
                    downBtn.title = '아래로 이동';
                    downBtn.onclick = (e) => {
                        e.stopPropagation();
                        moveChapterDown(key);
                    };
                    actions.appendChild(downBtn);
                }

                // 제목 수정
                const editBtn = document.createElement('button');
                editBtn.className = 'toc-action-btn edit';
                editBtn.innerHTML = '✏️';
                editBtn.title = '제목 수정';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    editChapterTitle(key);
                };
                actions.appendChild(editBtn);

                // 삭제
                if (!chapter.isSpecial) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'toc-action-btn delete';
                    deleteBtn.innerHTML = '🗑️';
                    deleteBtn.title = '삭제';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteChapter(key);
                    };
                    actions.appendChild(deleteBtn);
                }

                header.appendChild(actions);
                li.appendChild(header);

                // 하위 챕터
                if (chapter.children) {
                    const subUl = document.createElement('ul');
                    subUl.className = 'chapter-tree sub-chapter';
                    renderSubChaptersWithActions(chapter.children, subUl, key);
                    li.appendChild(subUl);
                }

                treeElement.appendChild(li);
            });
            
            // 모바일 목차 업데이트
            if (window.mobileUI && window.mobileUI.isInitialized) {
                setTimeout(() => window.mobileUI.refreshTocContent(), 100);
            }

        }

        // 하위 챕터 렌더링 (액션 버튼 포함)
        function renderSubChaptersWithActions(children, parentElement, prefix) {
            const keys = Object.keys(children);
            keys.forEach((key, index) => {
                const child = children[key];
                const fullKey = prefix + '-' + key;
                
                const li = document.createElement('li');
                li.className = 'chapter-item';
                li.dataset.chapterId = fullKey;

                const header = document.createElement('div');
                header.className = 'chapter-item-header';

                // 제목 영역 (토글 버튼 + 링크)
                const titleWrapper = document.createElement('div');
                titleWrapper.className = 'chapter-title-wrapper';

                if (child.children) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn expanded';
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleChapter(toggleBtn);
                    };
                    titleWrapper.appendChild(toggleBtn);
                }

                const link = document.createElement('a');
                link.className = 'chapter-link' + (chapterData[fullKey]?.content ? ' has-content' : '');
                link.textContent = child.title;
                link.setAttribute('data-id', fullKey);
                link.onclick = () => selectChapter(fullKey);
                titleWrapper.appendChild(link);

                header.appendChild(titleWrapper);

                // 액션 버튼들
                const actions = document.createElement('div');
                actions.className = 'toc-actions';
                
                // 위로
                if (index > 0) {
                    const upBtn = document.createElement('button');
                    upBtn.className = 'toc-action-btn up';
                    upBtn.innerHTML = '↑';
                    upBtn.title = '위로 이동';
                    upBtn.onclick = (e) => {
                        e.stopPropagation();
                        moveChapterUp(fullKey);
                    };
                    actions.appendChild(upBtn);
                }

                // 아래로
                if (index < keys.length - 1) {
                    const downBtn = document.createElement('button');
                    downBtn.className = 'toc-action-btn down';
                    downBtn.innerHTML = '↓';
                    downBtn.title = '아래로 이동';
                    downBtn.onclick = (e) => {
                        e.stopPropagation();
                        moveChapterDown(fullKey);
                    };
                    actions.appendChild(downBtn);
                }

                // 레벨업 (왼쪽)
                const leftBtn = document.createElement('button');
                leftBtn.className = 'toc-action-btn left';
                leftBtn.innerHTML = '←';
                leftBtn.title = '레벨 올리기 (상위로)';
                leftBtn.onclick = (e) => {
                    e.stopPropagation();
                    changeLevelUp(fullKey);
                };
                actions.appendChild(leftBtn);

                // 레벨다운 (오른쪽) - 첫 번째가 아닐 때만
                if (index > 0) {
                    const rightBtn = document.createElement('button');
                    rightBtn.className = 'toc-action-btn right';
                    rightBtn.innerHTML = '→';
                    rightBtn.title = '레벨 내리기 (하위로)';
                    rightBtn.onclick = (e) => {
                        e.stopPropagation();
                        changeLevelDown(fullKey);
                    };
                    actions.appendChild(rightBtn);
                }

                // 수정
                const editBtn = document.createElement('button');
                editBtn.className = 'toc-action-btn edit';
                editBtn.innerHTML = '✏️';
                editBtn.title = '제목 수정';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    editChapterTitle(fullKey);
                };
                actions.appendChild(editBtn);

                // 삭제
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'toc-action-btn delete';
                deleteBtn.innerHTML = '🗑️';
                deleteBtn.title = '삭제';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteChapter(fullKey);
                };
                actions.appendChild(deleteBtn);

                header.appendChild(actions);
                li.appendChild(header);

                if (child.children) {
                    const subUl = document.createElement('ul');
                    subUl.className = 'chapter-tree sub-sub-chapter';
                    renderSubChaptersWithActions(child.children, subUl, fullKey);
                    li.appendChild(subUl);
                }

                parentElement.appendChild(li);
            });
        }

        // 챕터 위로 이동
        function moveChapterUp(chapterId) {
            console.log('위로 이동:', chapterId);
            
            const parts = chapterId.split('-');
            
            // 부모 객체와 현재 레벨의 키들 찾기
            let parent, currentLevel, parentKeys;
            
            if (parts.length === 1) {
                // 최상위 레벨
                currentLevel = tableOfContents;
                parentKeys = Object.keys(tableOfContents);
            } else {
                // 하위 레벨
                parent = tableOfContents;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!parent[parts[i]]) return;
                    parent = parent[parts[i]];
                }
                
                if (!parent.children) return;
                currentLevel = parent.children;
                parentKeys = Object.keys(currentLevel);
            }
            
            const lastKey = parts[parts.length - 1];
            const currentIndex = parentKeys.indexOf(lastKey);
            
            if (currentIndex <= 0) {
                showMessage('이미 맨 위에 있습니다.', true);
                return;
            }
            
            // 위 항목과 순서 바꾸기
            const newKeys = [...parentKeys];
            [newKeys[currentIndex - 1], newKeys[currentIndex]] = [newKeys[currentIndex], newKeys[currentIndex - 1]];
            
            // 객체 재구성
            const newLevel = {};
            newKeys.forEach(key => {
                newLevel[key] = currentLevel[key];
            });
            
            // 부모 객체 업데이트
            if (parts.length === 1) {
                Object.keys(tableOfContents).forEach(key => delete tableOfContents[key]);
                Object.assign(tableOfContents, newLevel);
            } else {
                parent.children = newLevel;
            }
            
            saveTOCToLocalStorage();
            renderChapterTreeWithActions();
            showMessage('위로 이동했습니다.', false);
        }

        // 챕터 아래로 이동
        function moveChapterDown(chapterId) {
            console.log('아래로 이동:', chapterId);
            
            const parts = chapterId.split('-');
            
            // 부모 객체와 현재 레벨의 키들 찾기
            let parent, currentLevel, parentKeys;
            
            if (parts.length === 1) {
                // 최상위 레벨
                currentLevel = tableOfContents;
                parentKeys = Object.keys(tableOfContents);
            } else {
                // 하위 레벨
                parent = tableOfContents;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!parent[parts[i]]) return;
                    parent = parent[parts[i]];
                }
                
                if (!parent.children) return;
                currentLevel = parent.children;
                parentKeys = Object.keys(currentLevel);
            }
            
            const lastKey = parts[parts.length - 1];
            const currentIndex = parentKeys.indexOf(lastKey);
            
            if (currentIndex < 0 || currentIndex >= parentKeys.length - 1) {
                showMessage('이미 맨 아래에 있습니다.', true);
                return;
            }
            
            // 아래 항목과 순서 바꾸기
            const newKeys = [...parentKeys];
            [newKeys[currentIndex], newKeys[currentIndex + 1]] = [newKeys[currentIndex + 1], newKeys[currentIndex]];
            
            // 객체 재구성
            const newLevel = {};
            newKeys.forEach(key => {
                newLevel[key] = currentLevel[key];
            });
            
            // 부모 객체 업데이트
            if (parts.length === 1) {
                Object.keys(tableOfContents).forEach(key => delete tableOfContents[key]);
                Object.assign(tableOfContents, newLevel);
            } else {
                parent.children = newLevel;
            }
            
            saveTOCToLocalStorage();
            renderChapterTreeWithActions();
            showMessage('아래로 이동했습니다.', false);
        }

        // 레벨 올리기 (자식 → 형제)
        function changeLevelUp(chapterId) {
            console.log('레벨 올리기:', chapterId);
            
            const parts = chapterId.split('-');
            
            if (parts.length === 1) {
                showMessage('최상위 레벨은 더 이상 올릴 수 없습니다.', true);
                return;
            }
            
            // 현재 챕터 데이터 가져오기
            const chapter = getChapterById(chapterId);
            if (!chapter) {
                showMessage('챕터를 찾을 수 없습니다.', true);
                return;
            }
            
            // 부모 찾기
            let parent = tableOfContents;
            for (let i = 0; i < parts.length - 2; i++) {
                if (!parent[parts[i]] || !parent[parts[i]].children) return;
                parent = parent[parts[i]].children;
            }
            
            const parentKey = parts[parts.length - 2];
            const currentKey = parts[parts.length - 1];
            
            if (!parent[parentKey] || !parent[parentKey].children || !parent[parentKey].children[currentKey]) {
                showMessage('구조 오류가 발생했습니다.', true);
                return;
            }
            
            // 챕터 데이터 복사 (깊은 복사)
            const chapterData = JSON.parse(JSON.stringify(chapter));
            
            // 현재 위치에서 삭제
            delete parent[parentKey].children[currentKey];
            
            // children이 비어있으면 삭제
            if (Object.keys(parent[parentKey].children).length === 0) {
                delete parent[parentKey].children;
            }
            
            // 부모의 형제로 추가 (부모 바로 뒤에)
            const parentKeys = Object.keys(parent);
            const parentIndex = parentKeys.indexOf(parentKey);
            
            const newParent = {};
            let inserted = false;
            parentKeys.forEach((key, index) => {
                newParent[key] = parent[key];
                if (index === parentIndex && !inserted) {
                    // 새 키 생성 (기존 키 유지)
                    newParent[currentKey] = chapterData;
                    inserted = true;
                }
            });
            
            // 부모 레벨이 최상위인지 확인
            if (parts.length === 2) {
                // 최상위 레벨 재구성
                Object.keys(tableOfContents).forEach(key => delete tableOfContents[key]);
                Object.assign(tableOfContents, newParent);
            } else {
                // 상위 레벨 찾아서 업데이트
                let grandParent = tableOfContents;
                for (let i = 0; i < parts.length - 3; i++) {
                    grandParent = grandParent[parts[i]].children;
                }
                grandParent[parts[parts.length - 3]].children = newParent;
            }
            
            saveTOCToLocalStorage();
            renderChapterTreeWithActions();
            showMessage('레벨을 올렸습니다.', false);
        }

        // 레벨 내리기 (형제 → 자식)
        function changeLevelDown(chapterId) {
            console.log('레벨 내리기:', chapterId);
            
            const parts = chapterId.split('-');
            const lastKey = parts[parts.length - 1];
            
            // 현재 챕터 데이터 가져오기
            const chapter = getChapterById(chapterId);
            if (!chapter) {
                showMessage('챕터를 찾을 수 없습니다.', true);
                return;
            }
            
            // 부모 객체와 현재 레벨의 키들 찾기
            let parent, currentLevel, parentKeys;
            
            if (parts.length === 1) {
                // 최상위 레벨
                currentLevel = tableOfContents;
                parentKeys = Object.keys(tableOfContents);
            } else {
                // 하위 레벨
                parent = tableOfContents;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!parent[parts[i]]) return;
                    parent = parent[parts[i]];
                }
                
                if (!parent.children) return;
                currentLevel = parent.children;
                parentKeys = Object.keys(currentLevel);
            }
            
            const currentIndex = parentKeys.indexOf(lastKey);
            
            if (currentIndex <= 0) {
                showMessage('첫 번째 항목은 레벨을 내릴 수 없습니다.', true);
                return;
            }
            
            // 바로 위 형제
            const prevKey = parentKeys[currentIndex - 1];
            const prevSibling = currentLevel[prevKey];
            
            // 챕터 데이터 복사 (깊은 복사)
            const chapterData = JSON.parse(JSON.stringify(chapter));
            
            // 현재 위치에서 삭제
            delete currentLevel[lastKey];
            
            // 바로 위 형제의 children으로 추가
            if (!prevSibling.children) {
                prevSibling.children = {};
            }
            
            // 새 키 생성 (자식들의 마지막 번호 + 1)
            const childKeys = Object.keys(prevSibling.children);
            let newKey = lastKey;
            
            // 키 중복 방지
            if (prevSibling.children[newKey]) {
                let counter = 1;
                while (prevSibling.children[newKey + '-' + counter]) {
                    counter++;
                }
                newKey = newKey + '-' + counter;
            }
            
            prevSibling.children[newKey] = chapterData;
            
            saveTOCToLocalStorage();
            renderChapterTreeWithActions();
            showMessage('레벨을 내렸습니다.', false);
        }

        // 제목 수정
        function editChapterTitle(chapterId) {
            const chapter = getChapterById(chapterId);
            if (!chapter) return;

            const newTitle = prompt('새 제목을 입력하세요:', chapter.title);
            if (newTitle && newTitle.trim()) {
                chapter.title = newTitle.trim();
                saveTOCToLocalStorage();
                renderChapterTreeWithActions();
                showMessage('제목이 수정되었습니다.', false);
            }
        }

        // 챕터 삭제
        function deleteChapter(chapterId) {
            const chapter = getChapterById(chapterId);
            if (!chapter) return;

            if (!confirm(`"${chapter.title}"을(를) 삭제하시겠습니까?\n\n⚠️ 하위 챕터와 내용도 함께 삭제됩니다!`)) {
                return;
            }

            removeChapterById(chapterId);
            saveTOCToLocalStorage();
            renderChapterTreeWithActions();
            showMessage('챕터가 삭제되었습니다.', false);
        }

        // 새 챕터 추가
        function addNewChapter() {
            const titleInput = document.getElementById('newChapterTitle');
            const parentSelect = document.getElementById('newChapterParent');
            
            const title = titleInput.value.trim();
            const parentId = parentSelect.value;

            if (!title) {
                alert('제목을 입력해주세요.');
                return;
            }

            // 새 ID 생성
            const newId = generateNewChapterId(parentId);
            
            // 새 챕터 객체
            const newChapter = {
                title: title
            };

            // 부모가 있으면 children에 추가, 없으면 최상위에 추가
            if (parentId) {
                const parent = getChapterById(parentId);
                if (parent) {
                    if (!parent.children) {
                        parent.children = {};
                    }
                    parent.children[newId] = newChapter;
                }
            } else {
                tableOfContents[newId] = newChapter;
            }

            saveTOCToLocalStorage();
            renderChapterTreeWithActions();
            populateParentSelect();
            
            // 입력 필드 초기화
            titleInput.value = '';
            parentSelect.value = '';
            
            showMessage(`"${title}" 챕터가 추가되었습니다.`, false);
        }

        // 새 챕터 추가 취소
        function cancelAddChapter() {
            document.getElementById('newChapterTitle').value = '';
            document.getElementById('newChapterParent').value = '';
        }

        // 부모 선택 드롭다운 채우기
        function populateParentSelect() {
            const select = document.getElementById('newChapterParent');
            select.innerHTML = '<option value="">최상위 레벨로 추가</option>';

            function addOptions(obj, prefix = '', indent = '') {
                Object.keys(obj).forEach(key => {
                    const chapter = obj[key];
                    if (chapter.isSpecial) return; // 특수 항목 제외
                    
                    const option = document.createElement('option');
                    option.value = prefix + key;
                    option.textContent = indent + chapter.title;
                    select.appendChild(option);

                    if (chapter.children) {
                        addOptions(chapter.children, prefix + key + '-', indent + '  ');
                    }
                });
            }

            addOptions(tableOfContents);
        }

        // 새 챕터 ID 생성
        function generateNewChapterId(parentId) {
            if (!parentId) {
                // 최상위 레벨
                const keys = Object.keys(tableOfContents);
                let maxNum = 0;
                keys.forEach(key => {
                    if (key.startsWith('new')) {
                        const num = parseInt(key.replace('new', '')) || 0;
                        maxNum = Math.max(maxNum, num);
                    }
                });
                return 'new' + (maxNum + 1);
            } else {
                // 하위 레벨
                const parent = getChapterById(parentId);
                if (!parent || !parent.children) return 'new1';
                
                const keys = Object.keys(parent.children);
                let maxNum = 0;
                keys.forEach(key => {
                    const num = parseInt(key) || 0;
                    maxNum = Math.max(maxNum, num);
                });
                return String(maxNum + 1);
            }
        }

        // ID로 챕터 찾기
        function getChapterById(chapterId) {
            const parts = chapterId.split('-');
            let current = tableOfContents;
            
            for (let i = 0; i < parts.length; i++) {
                if (!current[parts[i]]) return null;
                if (i === parts.length - 1) {
                    return current[parts[i]];
                }
                current = current[parts[i]].children;
                if (!current) return null;
            }
            return null;
        }

        // ID로 챕터 삭제
        function removeChapterById(chapterId) {
            const parts = chapterId.split('-');
            
            if (parts.length === 1) {
                // 최상위 레벨
                delete tableOfContents[chapterId];
                return;
            }

            // 하위 레벨
            let current = tableOfContents;
            for (let i = 0; i < parts.length - 1; i++) {
                if (!current[parts[i]] || !current[parts[i]].children) return;
                current = current[parts[i]].children;
            }
            delete current[parts[parts.length - 1]];
        }

        // TOC를 로컬 스토리지에 저장
        function saveTOCToLocalStorage() {
            localStorage.setItem('tableOfContents', JSON.stringify(tableOfContents));
            updateProgress(); // 진행률도 업데이트
        }

        // 페이지 로드 시 저장된 TOC 불러오기
        function loadTOCFromLocalStorage() {
            const saved = localStorage.getItem('tableOfContents');
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    Object.assign(tableOfContents, loaded);
                    console.log('✅ 저장된 목차를 불러왔습니다.');
                } catch (e) {
                    console.error('❌ 목차 로드 실패:', e);
                }
            }
        }

    </script>
</body>
    <!-- 제목 편집 통합 - 모든 함수 정의 후 로드 -->\r\n    <script src="title-integration.js"></script>
    <!-- 편집기 개선 패치 -->
    <script src="editor-improvements.js"></script>
</html>
