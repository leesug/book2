<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자유의지 예측 - 집필 시스템</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        /* 진행률 상태 바 */
        .progress-bar-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 30px;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .progress-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .progress-info h2 {
            font-size: 18px;
            margin: 0;
            font-weight: 600;
        }

        .progress-stats {
            display: flex;
            gap: 15px;
            font-size: 14px;
        }

        .progress-stat {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 500;
        }

        .progress-bar-wrapper {
            flex: 1;
            max-width: 400px;
            margin: 0 30px;
        }

        .progress-bar-bg {
            background: rgba(255,255,255,0.3);
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-fill {
            background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .progress-percentage {
            font-size: 20px;
            font-weight: 700;
            min-width: 60px;
            text-align: right;
        }

        .container {
            display: flex;
            height: calc(100vh - 54px);
        }

        /* 사이드바 - 목차 */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            flex-shrink: 0;
        }

        .sidebar h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }

        .chapter-tree {
            list-style: none;
        }

        .chapter-item {
            margin: 5px 0;
        }

        .chapter-item-header {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .toggle-btn {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #666;
            background: transparent;
            border: 1px solid #ccc;
            border-radius: 3px;
            transition: all 0.2s;
            flex-shrink: 0;
            user-select: none;
        }

        .toggle-btn:hover {
            background: #e0e0e0;
            color: #333;
            border-color: #999;
        }

        .toggle-btn.collapsed::before {
            content: '+';
        }

        .toggle-btn.expanded::before {
            content: '−';
        }

        .chapter-link {
            display: block;
            padding: 8px 12px;
            text-decoration: none;
            color: #333;
            border-radius: 5px;
            transition: all 0.2s;
            cursor: pointer;
            font-size: 14px;
            flex: 1;
        }

        .chapter-link:hover {
            background: #f0f0f0;
        }

        .chapter-link.active {
            background: #4CAF50;
            color: white;
        }

        .chapter-link.has-content {
            font-weight: 600;
            color: #4CAF50;
        }

        .chapter-link.has-content.active {
            color: white;
        }

        .sub-chapter {
            margin-left: 25px;
            overflow: hidden;
            max-height: 5000px;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .sub-chapter.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .sub-sub-chapter {
            margin-left: 25px;
            font-size: 13px;
            overflow: hidden;
            max-height: 5000px;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .sub-sub-chapter.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        /* 메인 콘텐츠 */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
            min-width: 0;
        }

        /* 글쓰기 가이드 패널 */
        .guide-panel {
            width: 350px;
            background: #f9f9f9;
            border-left: 1px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            flex-shrink: 0;
            display: none;
        }

        .guide-panel.active {
            display: block;
        }

        .guide-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4CAF50;
        }

        .guide-header h3 {
            font-size: 18px;
            color: #333;
            margin: 0;
        }

        .guide-content {
            line-height: 1.8;
            font-size: 14px;
            color: #555;
        }

        .guide-content h4 {
            font-size: 16px;
            color: #4CAF50;
            margin: 20px 0 10px 0;
        }

        .guide-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .guide-content li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .guide-loading {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .guide-loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .btn-guide {
            background: #9C27B0;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn-guide:hover {
            background: #7B1FA2;
        }

        .content-header {
            padding: 20px 30px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-header h2 {
            font-size: 22px;
            color: #333;
        }

        .content-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .btn-small {
            padding: 5px 12px;
            font-size: 12px;
            background: #607D8B;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-small:hover {
            background: #546E7A;
        }

        /* 편집기 영역 */
        .editor-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .view-mode {
            line-height: 1.8;
            font-size: 15px;
            color: #333;
        }

        .view-mode h1 {
            font-size: 28px;
            margin: 30px 0 20px 0;
            color: #222;
        }

        .view-mode h2 {
            font-size: 24px;
            margin: 25px 0 15px 0;
            color: #333;
        }

        .view-mode h3 {
            font-size: 20px;
            margin: 20px 0 10px 0;
            color: #444;
        }

        .view-mode p {
            margin: 15px 0;
        }

        .view-mode hr {
            margin: 30px 0;
            border: none;
            border-top: 2px solid #ddd;
        }

        .view-mode img {
            width: 80%;
            height: auto;
            margin: 20px auto;
            display: block;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .view-mode table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        .view-mode table th,
        .view-mode table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .view-mode table th {
            background: #f5f5f5;
            font-weight: 600;
        }

        .toolbar {
            background: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .toolbar button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #f0f0f0;
        }

        #contentEditor {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 15px;
            line-height: 1.8;
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            resize: vertical;
        }

        .content-editor-editable {
            background: white;
            overflow-y: auto;
            max-height: 600px;
        }

        .content-editor-editable:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }

        .content-editor-editable img {
            width: 80%;
            height: auto;
            margin: 20px auto;
            display: block;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        .content-editor-editable p {
            margin: 10px 0;
        }

        .content-editor-editable h1,
        .content-editor-editable h2,
        .content-editor-editable h3 {
            margin: 20px 0 10px 0;
        }

        .content-editor-editable table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        .content-editor-editable table th,
        .content-editor-editable table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .content-editor-editable table th {
            background: #f5f5f5;
            font-weight: 600;
        }

        #editorWrapper {
            position: relative;
        }

        #dropOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(76, 175, 80, 0.1);
            border: 3px dashed #4CAF50;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }

        .attachments {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        .attachments h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
        }

        .attachment-list {
            list-style: none;
        }

        .attachment-item {
            padding: 10px;
            background: #f9f9f9;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .attachment-item a {
            color: #2196F3;
            text-decoration: none;
        }

        .attachment-item a:hover {
            text-decoration: underline;
        }

        .file-upload-area {
            margin-top: 15px;
            padding: 20px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-area:hover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .empty-state {
            text-align: center;
            padding: 100px 20px;
            color: #999;
        }

        .empty-state h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #999;
        }

        /* 스크롤바 스타일 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #4CAF50;
            color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .status-message.error {
            background: #f44336;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
    <!-- 목차 관리 시스템 -->
    <script src="toc-manager.js"></script>

</head>
<body>
    <!-- 진행률 상태 바 -->
    <div class="progress-bar-container">
        <div class="progress-info">
            <h2>📚 자유의지 예측</h2>
            <div class="progress-stats">
                <span class="progress-stat" id="pagesWritten">0 / 500 페이지</span>
                <span class="progress-stat" id="chaptersCompleted">0 / 0 챕터</span>
                <span class="progress-stat" id="totalChars">0 / 337,500 자</span>
            </div>
        </div>
        <div class="progress-bar-wrapper">
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="progressBarFill" style="width: 0%;">
                    <span id="progressBarText"></span>
                </div>
            </div>
        </div>
        <div class="progress-percentage" id="progressPercentage">0%</div>
    </div>

    <div class="container">
        <!-- 사이드바 - 목차 -->
        <div class="sidebar">
            <h1>📖 자유의지 예측</h1>
            <div style="margin-bottom: 15px; text-align: right;">
                <button id="collapseAllBtn" class="btn btn-small" style="font-size: 12px; padding: 5px 12px;">
                    − 모두 접기
                </button>
            </div>
            <ul class="chapter-tree" id="chapterTree">
                <!-- JavaScript로 동적 생성 -->
            </ul>
        </div>

        <!-- 메인 콘텐츠 -->
        <div class="main-content">
            <div class="content-header">
                <h2 id="contentTitle">챕터를 선택해주세요</h2>
                <div class="content-actions" id="contentActions" style="display: none;">
                    <button class="btn btn-secondary" id="editBtn" style="display: none;">수정</button>
                    <button class="btn btn-primary" id="saveBtn" style="display: none;">저장</button>
                    <button class="btn btn-danger" id="cancelBtn" style="display: none;">취소</button>
                </div>
            </div>

            <div class="editor-area" id="editorArea">
                <div class="empty-state">
                    <h3>📝 집필을 시작하세요</h3>
                    <p>왼쪽 목차에서 챕터를 선택하면 내용을 작성하거나 수정할 수 있습니다.</p>
                </div>
            </div>
        </div>

        <!-- 글쓰기 가이드 패널 -->
        <div class="guide-panel" id="guidePanel">
            <div class="guide-header">
                <h3>✍️ 글쓰기 가이드</h3>
                <button class="btn-guide" id="regenerateGuideBtn" onclick="regenerateGuide()">🔄 재가이드 생성</button>
            </div>
            <div class="guide-content" id="guideContent">
                <p style="color: #999; text-align: center; padding: 40px 20px;">챕터를 선택하면 글쓰기 가이드가 표시됩니다.</p>
            </div>
        </div>
    </div>

    <script>
        // API Base URL 설정 (로컬/프로덕션 자동 감지)
        const API_BASE_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000' 
            : window.location.origin;
        
        console.log('🔗 API Base URL:', API_BASE_URL);
        
        // 목차 데이터
        const tableOfContents = {
            "bookInfo": {
                title: "📋 책 기본 정보",
                isSpecial: true
            },
            "prologue": {
                title: "프롤로그: 인류의 숙명, 예측에 대한 갈망",
                children: {
                    "p1": { title: "왜 우리는 예측하려 하는가?" },
                    "p2": { title: "예측의 본능: 생존과 번영을 위한 인류의 역사" },
                    "p3": { title: "예측이 성공했을 때의 보상: 역사 속 사례와 현대 사회의 가치" },
                    "p4": { title: "같은 실수를 반복하는 이유: 예측 불가능성이 주는 좌절과 혼란" },
                    "p5": { title: "예측의 당위성: 더 나은 삶을 위한 필수적인 지혜" },
                    "p6": { title: "예측을 위한 인류의 도구들: 과학기술에서 동양의 지혜까지" },
                    "p7": { title: "시간과 공간을 읽어내는 도구: 시계, 달력, 천문학" },
                    "p8": { title: "자연 현상 예측: 날씨 예측의 역사와 발전" },
                    "p9": { title: "사회 현상 예측: 역사의 반복, 유행의 순환 (패션, 음악)" },
                    "p10": { title: "빅데이터와 AI: 모든 과학기술은 예측을 향한다" },
                    "p11": { title: "예측만을 위한 학문: 동양의 점술과 사주명리" },
                    "p12": { title: "과학기술로 설명할 수 없는 기호와 의지의 문제" },
                    "p13": { title: "결과와 과정: 점술/사주명리가 가진 독특한 설득력" },
                    "p14": { title: "'두루뭉술한' 예측의 오해와 '구체화된' 예측의 정확성" },
                    "p15": { title: "한국, 예측의 특이점: 점술 시장의 비밀" },
                    "p16": { title: "전 세계 인구 대비 압도적인 한국의 점술 시장" },
                    "p17": { title: "한국 점술의 특이성: '과거 해소'보다 '미래 예측'에 집중하는 문화" },
                    "p18": { title: "'신들의 나라' 한국이 점술에 열광하는 이유" },
                    "p19": { title: "점술과 사주명리의 경계, 그리고 '역사주'의 등장" },
                    "p20": { title: "예측 툴로서의 점술과 사주명리의 공통점과 차이점" },
                    "p21": { title: "사주명리: 달력의 원리에 기반한 역학" },
                    "p22": { title: "점술의 두 갈래: 사주명리의 미분(세분화) 개념과 신접(神接)의 세계" },
                    "p23": { title: "비과학적 근거에 대한 비판과 그럼에도 불구하고 믿는 이유" },
                    "p24": { title: "예측률의 한계: 70%와 55%, 믿을 수 없는 예측과 소름 돋는 예측" },
                    "p25": { title: "사주명리, 오래된 기술이 된 이유" },
                    "p26": { title: "반만년 역사 속에서 '원리'보다 '기술'로 전수된 지혜" },
                    "p27": { title: "어설프게 맞지만, 왜 맞는지는 몰랐던 과거의 한계" },
                    "p28": { title: "'비급'과 '비밀': 예측의 가치가 만들어낸 폐쇄성" },
                    "p29": { title: "새로운 예측의 시대: '역사주'의 탄생 배경" },
                    "p30": { title: "과거의 실망을 넘어선 새로운 시도" },
                    "p31": { title: "'오행의 정체'와 '운, 기'의 현대적 재해석" },
                    "p32": { title: "시간과 에너지: '역사주'가 예측의 새로운 지평을 열다" }
                }
            },
            "part1": {
                title: "제1부. '역사주'의 근간: 음양오행, 변화하는 에너지",
                children: {
                    "1-1": {
                        title: "무극에서 음양으로: 모든 것의 시작",
                        children: {
                            "1-1-1": { title: "무극의 상태와 시간의 발생" },
                            "1-1-2": { title: "에너지와 시간: 아인슈타인의 방정식으로 본 관계" },
                            "1-1-3": { title: "음양의 발생: 에너지 차이에 의한 편차" },
                            "1-1-4": { title: "음양에서 오행으로: 에너지의 흐름과 균형" },
                            "1-1-5": { title: "오행의 분화와 에너지 준위" },
                            "1-1-6": { title: "오행의 특성: 목, 화, 토, 금, 수" }
                        }
                    },
                    "1-2": {
                        title: "고정적이지 않은 오행: 불변하지 않고 변화하며 상대적인 오행",
                        children: {
                            "1-2-1": { title: "십간(十干): 변화하는 오행의 표현" },
                            "1-2-2": { title: "천간의 음양과 오행 분류" },
                            "1-2-3": { title: "십간의 물리적/자연적 특징과 대표 물상" }
                        }
                    },
                    "1-3": {
                        title: "오행의 상호작용: 생(生), 극(剋), 충(沖), 합(合)",
                        children: {
                            "1-3-1": { title: "충과 합의 파동적 증명: 보강 간섭과 상쇄 간섭" },
                            "1-3-2": { title: "오행의 합화 현상 (굴절, 역화)" }
                        }
                    },
                    "1-4": {
                        title: "십성(十星): 인간 본연의 욕구와 에너지",
                        children: {
                            "1-4-1": { title: "십성이란 무엇이며, 왜 나타나는가" },
                            "1-4-2": { title: "본원(기준 오행)과 십성: 나와 오행의 관계 (육친)" },
                            "1-4-3": { title: "십성의 원리: 에너지 준위와 심리적/행동적 특성" }
                        }
                    },
                    "1-5": { title: "토체(질량체)를 지나는 십간의 지연 현상: 12지지의 탄생 원리" }
                }
            },
            "part2": {
                title: "제2부. 운과 기: 시간과 에너지의 실체적 발현",
                children: {
                    "2-1": {
                        title: "운(運)과 기(氣)의 명명: 천간과 지지",
                        children: {
                            "2-1-1": { title: "운(천간): 때, 시점, 주기적 변화" },
                            "2-1-2": { title: "기(지지): 기세, 에너지, 힘, 주변 환경의 영향" },
                            "2-1-3": { title: "운기(運氣)의 실제: 천간은 기를 담는 그릇" }
                        }
                    },
                    "2-2": {
                        title: "운기의 자연 현상: 과학적 연결고리",
                        children: {
                            "2-2-1": { title: "원자의 전자 오비탈과 채움 순서" },
                            "2-2-2": { title: "도파민과 도파민 수용체" },
                            "2-2-3": { title: "호르몬과 호르몬 수용체" },
                            "2-2-4": { title: "각종 바이러스와 접촉 수용체" },
                            "2-2-5": { title: "남자와 여자의 성기 모습 차이: 운기와 질량체의 관계" }
                        }
                    },
                    "2-3": {
                        title: "60갑자: 운기의 기본 구성 원리",
                        children: {
                            "2-3-1": { title: "60갑자의 종류와 자체 투간" }
                        }
                    },
                    "2-4": {
                        title: "지지(地支)와 지장간(地藏干): 운기 발현의 깊이",
                        children: {
                            "2-4-1": { title: "12지지의 구성과 지장간의 발현 순서" },
                            "2-4-2": { title: "지장간의 수치: 기의 크기" }
                        }
                    },
                    "2-5": {
                        title: "투간(透干): 지장간의 에너지가 천간으로 발현되는 현상",
                        children: {
                            "2-5-1": { title: "신강(身强)과 신약(身弱)의 재해석" }
                        }
                    },
                    "2-6": {
                        title: "사주팔자: 삶의 운기 구조",
                        children: {
                            "2-6-1": { title: "년월일시 사주의 구성과 의미" },
                            "2-6-2": { title: "사주의 기점: 출생 시점에 정해지는 운기" },
                            "2-6-3": { title: "일상생활에서 사주의 작동 원리 경험" }
                        }
                    },
                    "2-7": {
                        title: "현운(現運): 오늘의 운세와 사주의 상호작용",
                        children: {
                            "2-7-1": { title: "여러 운기의 동시 작용 계산: 음양 삼합론" },
                            "2-7-2": { title: "운기의 작동 모델: 홀덤 게임 비유" }
                        }
                    }
                }
            },
            "part3": {
                title: "제3부. '역사주' 핵심 이론: 본원 이동, 수용운, 합화",
                children: {
                    "3-1": {
                        title: "본원(本源) 이동론: 삶의 변화를 읽는 새로운 기준점",
                        children: {
                            "3-1-1": { title: "근묘화실(根苗花實) 원리부터 시작하는 본원의 변화" },
                            "3-1-2": { title: "본원이동의 시기: 18년 주기와 그 증거" },
                            "3-1-3": { title: "나이가 들수록 죽음에 이르는 과정: 생명은 소용돌이와 같다" }
                        }
                    },
                    "3-2": {
                        title: "수용운(受容運)론: 십간 움직임의 원리",
                        children: {
                            "3-2-1": { title: "음양오행 원리의 세분화" },
                            "3-2-2": { title: "토체(질량체)에 대한 지체 및 복사 현상" },
                            "3-2-3": { title: "이성질체(짝수): 오른쪽 나선만 존재하는 세상" },
                            "3-2-4": { title: "천간의 개수 증가가 운의 감소를 의미하는 이유" },
                            "3-2-5": { title: "지장간의 크기와 운의 크기 및 능력" }
                        }
                    },
                    "3-3": {
                        title: "합화(合化)론: 운기의 로렌츠 나비 곡선",
                        children: {
                            "3-3-1": { title: "오행의 합화: 본래의 오행을 버리고 다른 오행으로 바뀌는 현상" },
                            "3-3-2": { title: "지장간의 크기와 합화: 오운의 나비" },
                            "3-3-3": { title: "로렌츠의 나비 곡선과 합화 현상의 유사성" }
                        }
                    }
                }
            },
            "part4": {
                title: "제4부. '역사주'의 다양한 운: 삶의 에너지를 읽다",
                children: {
                    "4-1": {
                        title: "인체의 운기: 중운(中運)",
                        children: {
                            "4-1-1": { title: "인류 보편의 신체적 특징과 운기 변화의 관계" },
                            "4-1-2": { title: "5년 주기 체중운의 시작과 변화" },
                            "4-1-3": { title: "경락을 통한 운기의 느낌" },
                            "4-1-4": { title: "경락의 생성과 오행 반응" },
                            "4-1-5": { title: "오행별 체질과 특징" },
                            "4-1-6": { title: "오행과 표정: 운기가 감정에 미치는 영향" }
                        }
                    },
                    "4-2": {
                        title: "삶의 큰 흐름: 체장운과 대운",
                        children: {
                            "4-2-1": { title: "대운: 월운의 10년 주기 변화" },
                            "4-2-2": { title: "체대운: 근묘화실의 원리에 의한 18년 주기 변화" },
                            "4-2-3": { title: "에너지 흐름에 따른 차이 인식" }
                        }
                    },
                    "4-3": {
                        title: "현재의 운: 현운(現運)",
                        children: {
                            "4-3-1": { title: "현운: 현재의 년월일시 운기" },
                            "4-3-2": { title: "현운의 다양성과 공통 적용" },
                            "4-3-3": { title: "사주와 현운의 합쳐진 해석의 중요성" }
                        }
                    },
                    "4-4": {
                        title: "장소의 운기: 지운과 장운",
                        children: {
                            "4-4-1": { title: "지운: 지구의 경도별/위도별 오행 설정과 작용" },
                            "4-4-2": { title: "지운의 시기별 변화: 태양의 고도와 에너지 보정" },
                            "4-4-3": { title: "장운: 20년 주기의 운, 풍수지리와 전쟁/정복의 역사" },
                            "4-4-4": { title: "지운의 특징 및 개운법 활용" }
                        }
                    }
                }
            },
            "part5": {
                title: "제5부. '역사주' 예측의 완성: 인생 그래프와 개운 전략",
                children: {
                    "5-1": {
                        title: "인생 그래프의 도출과 기본 해석",
                        children: {
                            "5-1-1": { title: "'역사주' 인생 그래프의 역할" },
                            "5-1-2": { title: "충의 적용과 그래프 해석" },
                            "5-1-3": { title: "십성과 합화로 그래프 보는 방법" }
                        }
                    },
                    "5-2": {
                        title: "예측의 정확성을 높이는 오차 수정",
                        children: {
                            "5-2-1": { title: "균시차와 태양시" },
                            "5-2-2": { title: "달력 오차: 지구 공전일과 윤년의 영향" },
                            "5-2-3": { title: "일, 월, 년이 바뀌는 포인트" },
                            "5-2-4": { title: "운기의 불확실성: 미발견 운기 및 예측의 한계" }
                        }
                    },
                    "5-3": {
                        title: "'역사주' 실전 해석 사례",
                        children: {
                            "5-3-1": { title: "실제 인생 그래프와 사례를 통한 해석 방법" },
                            "5-3-2": { title: "사고 사례 분석: 운기 작용 과정" },
                            "5-3-3": { title: "궁합 사례 분석" }
                        }
                    },
                    "5-4": {
                        title: "'역사주'를 통한 개운 전략",
                        children: {
                            "5-4-1": { title: "운기의 작동 과정: 외부 운, 고유 운, 선택과 의지" },
                            "5-4-2": { title: "운세의 변수 조정" },
                            "5-4-3": { title: "좋은 운의 극대화와 나쁜 운의 회피 전략" },
                            "5-4-4": { title: "결혼, 사업, 취업 등에 운기가 미치는 영향과 활용" }
                        }
                    }
                }
            },
            "epilogue": {
                title: "에필로그: AI 시대, '역사주'와 상생하다",
                children: {
                    "e1": { title: "AI와의 경쟁과 상생: 인간 예측의 가치" },
                    "e2": { title: "'역사주'가 제시하는 삶의 새로운 지도와 통찰" },
                    "e3": { title: "'역사주' 공부의 의미와 활용 방안" },
                    "e4": { title: "'역사주'의 한계와 개운의 가능성" }
                }
            }
        };

        let currentChapterId = null;
        let isEditMode = false;
        let originalContent = '';
        let chapterData = {};

        const TOTAL_PAGES = 500;
        const CHARS_PER_PAGE = 675; // A5 기준, 25행 × 27자 = 675자

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            await loadChapterData();
            renderChapterTree();
            updateProgress();
            
            // 모두 접기/펼치기 버튼 이벤트
            const collapseBtn = document.getElementById('collapseAllBtn');
            let isAllCollapsed = false;
            
            collapseBtn.addEventListener('click', () => {
                const allToggles = document.querySelectorAll('.toggle-btn');
                const allSubLists = document.querySelectorAll('.sub-chapter, .sub-sub-chapter');
                
                if (isAllCollapsed) {
                    // 모두 펼치기
                    allToggles.forEach(btn => {
                        btn.classList.remove('collapsed');
                        btn.classList.add('expanded');
                    });
                    allSubLists.forEach(ul => {
                        ul.classList.remove('collapsed');
                    });
                    collapseBtn.textContent = '− 모두 접기';
                    isAllCollapsed = false;
                } else {
                    // 모두 접기
                    allToggles.forEach(btn => {
                        btn.classList.remove('expanded');
                        btn.classList.add('collapsed');
                    });
                    allSubLists.forEach(ul => {
                        ul.classList.add('collapsed');
                    });
                    collapseBtn.textContent = '+ 모두 펼치기';
                    isAllCollapsed = true;
                }
            });
        });

        // 진행률 계산
        function calculateProgress() {
            let totalChars = 0;
            let completedChapters = 0;
            let totalChapters = 0;

            // 모든 챕터 순회
            function countChapters(obj, prefix = '') {
                Object.keys(obj).forEach(key => {
                    if (key === 'bookInfo') return; // 책 기본 정보는 제외
                    
                    const fullKey = prefix ? `${prefix}-${key}` : key;
                    const item = obj[key];

                    if (item.children) {
                        countChapters(item.children, fullKey);
                    } else {
                        totalChapters++;
                        const data = chapterData[fullKey];
                        if (data && data.content) {
                            // HTML 태그 제거하고 텍스트만 카운트
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = data.content;
                            const textContent = tempDiv.textContent || tempDiv.innerText || '';
                            const chars = textContent.trim().length;
                            
                            if (chars > 0) {
                                totalChars += chars;
                                if (chars >= 100) { // 최소 100자 이상이면 완료로 간주
                                    completedChapters++;
                                }
                            }
                        }
                    }
                });
            }

            countChapters(tableOfContents);

            const pagesWritten = Math.floor(totalChars / CHARS_PER_PAGE);
            const percentage = Math.min(100, (pagesWritten / TOTAL_PAGES) * 100);

            return {
                pagesWritten,
                totalPages: TOTAL_PAGES,
                percentage: percentage.toFixed(1),
                completedChapters,
                totalChapters,
                totalChars
            };
        }

        // 진행률 UI 업데이트
        function updateProgress() {
            const progress = calculateProgress();

            document.getElementById('pagesWritten').textContent = 
                `${progress.pagesWritten} / ${progress.totalPages} 페이지`;
            
            document.getElementById('chaptersCompleted').textContent = 
                `${progress.completedChapters} / ${progress.totalChapters} 챕터`;
            
            // 총 글자수 표시 (천 단위 쉼표 추가)
            document.getElementById('totalChars').textContent = 
                `${progress.totalChars.toLocaleString()} / 337,500 자`;
            
            document.getElementById('progressPercentage').textContent = 
                `${progress.percentage}%`;
            
            const fillElement = document.getElementById('progressBarFill');
            fillElement.style.width = `${progress.percentage}%`;
            
            // 진행률에 따른 색상 변경
            const percentage = parseFloat(progress.percentage);
            let gradientColor;
            if (percentage < 30) {
                gradientColor = 'linear-gradient(90deg, #f44336 0%, #e91e63 100%)'; // 빨강
            } else if (percentage < 70) {
                gradientColor = 'linear-gradient(90deg, #FF9800 0%, #FFC107 100%)'; // 노랑
            } else {
                gradientColor = 'linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%)'; // 초록
            }
            fillElement.style.background = gradientColor;
            
            if (progress.percentage > 5) {
                document.getElementById('progressBarText').textContent = 
                    `${progress.percentage}%`;
            } else {
                document.getElementById('progressBarText').textContent = '';
            }
        }

        // 챕터 데이터 로드
        async function loadChapterData() {
            try {
                const response = await fetch('/api/chapters');
                chapterData = await response.json();
            } catch (error) {
                console.error('데이터 로드 실패:', error);
                showMessage('데이터를 불러오는데 실패했습니다.', true);
            }
        }

        // 목차 트리 렌더링
        function renderChapterTree() {
            const treeElement = document.getElementById('chapterTree');
            treeElement.innerHTML = '';

            Object.keys(tableOfContents).forEach(key => {
                const chapter = tableOfContents[key];
                const li = document.createElement('li');
                li.className = 'chapter-item';

                // 헤더 컨테이너 생성
                const header = document.createElement('div');
                header.className = 'chapter-item-header';

                // 자식이 있으면 토글 버튼 추가
                if (chapter.children) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn expanded';
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleChapter(toggleBtn);
                    };
                    header.appendChild(toggleBtn);
                }

                const link = document.createElement('a');
                link.className = 'chapter-link' + (chapterData[key]?.content ? ' has-content' : '');
                link.textContent = chapter.title;
                link.onclick = () => selectChapter(key);

                header.appendChild(link);
                li.appendChild(header);

                if (chapter.children) {
                    const subUl = document.createElement('ul');
                    subUl.className = 'chapter-tree sub-chapter';
                    renderSubChapters(chapter.children, subUl, key);
                    li.appendChild(subUl);
                }

                treeElement.appendChild(li);
            });
        }

        // 하위 챕터 렌더링
        function renderSubChapters(children, parentElement, prefix) {
            Object.keys(children).forEach(key => {
                const child = children[key];
                const fullKey = prefix + '-' + key;
                
                const li = document.createElement('li');
                li.className = 'chapter-item';

                // 헤더 컨테이너 생성
                const header = document.createElement('div');
                header.className = 'chapter-item-header';

                // 자식이 있으면 토글 버튼 추가
                if (child.children) {
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn expanded';
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleChapter(toggleBtn);
                    };
                    header.appendChild(toggleBtn);
                }

                const link = document.createElement('a');
                link.className = 'chapter-link' + (chapterData[fullKey]?.content ? ' has-content' : '');
                link.textContent = child.title;
                link.onclick = () => selectChapter(fullKey);

                header.appendChild(link);
                li.appendChild(header);

                if (child.children) {
                    const subUl = document.createElement('ul');
                    subUl.className = 'chapter-tree sub-sub-chapter';
                    renderSubChapters(child.children, subUl, fullKey);
                    li.appendChild(subUl);
                }

                parentElement.appendChild(li);
            });
        }

        // 챕터 토글 (접기/펼치기)
        function toggleChapter(button) {
            const li = button.closest('.chapter-item');
            const subList = li.querySelector('ul');
            
            if (!subList) return;

            if (button.classList.contains('expanded')) {
                // 접기
                button.classList.remove('expanded');
                button.classList.add('collapsed');
                subList.classList.add('collapsed');
            } else {
                // 펼치기
                button.classList.remove('collapsed');
                button.classList.add('expanded');
                subList.classList.remove('collapsed');
            }
        }

        // 챕터 선택
        async function selectChapter(chapterId) {
            if (isEditMode && currentChapterId !== chapterId) {
                if (!confirm('저장하지 않은 내용이 있습니다. 계속하시겠습니까?')) {
                    return;
                }
            }

            currentChapterId = chapterId;
            
            // 모든 링크에서 active 제거
            document.querySelectorAll('.chapter-link').forEach(link => {
                link.classList.remove('active');
            });

            // 현재 링크에 active 추가
            event.target.classList.add('active');

            // 챕터 데이터 로드
            await loadChapterContent(chapterId);
            
            // 가이드 패널 표시 및 가이드 생성
            showGuidePanel();
            await generateGuide(chapterId);
        }

        // 챕터 내용 로드
        async function loadChapterContent(chapterId) {
            try {
                const response = await fetch(`/api/chapters/${chapterId}`);
                const data = await response.json();

                const title = getChapterTitle(chapterId);
                document.getElementById('contentTitle').textContent = title;
                document.getElementById('contentActions').style.display = 'flex';

                if (data.content) {
                    // 내용이 있으면 뷰 모드로 표시
                    renderViewMode(data);
                } else {
                    // 내용이 없으면 바로 편집 모드
                    enterEditMode({ content: '', attachments: [] });
                }
            } catch (error) {
                console.error('챕터 로드 실패:', error);
                showMessage('챕터를 불러오는데 실패했습니다.', true);
            }
        }

        // 챕터 제목 가져오기
        function getChapterTitle(chapterId) {
            const parts = chapterId.split('-');
            
            if (parts.length === 1) {
                return tableOfContents[parts[0]]?.title || '';
            } else if (parts.length === 2) {
                return tableOfContents[parts[0]]?.children[parts[1]]?.title || '';
            } else if (parts.length === 3) {
                return tableOfContents[parts[0]]?.children[parts[1]]?.children[parts[2]]?.title || '';
            }
            
            return '';
        }

        // 뷰 모드 렌더링
        function renderViewMode(data) {
            isEditMode = false;
            document.getElementById('editBtn').style.display = 'inline-block';
            document.getElementById('saveBtn').style.display = 'none';
            document.getElementById('cancelBtn').style.display = 'none';

            const editorArea = document.getElementById('editorArea');
            editorArea.innerHTML = `
                <div class="view-mode">
                    ${data.content}
                </div>
                ${renderAttachments(data.attachments || [], false)}
            `;
        }

        // 편집 모드 진입
        function enterEditMode(data) {
            isEditMode = true;
            originalContent = data.content;
            
            document.getElementById('editBtn').style.display = 'none';
            document.getElementById('saveBtn').style.display = 'inline-block';
            document.getElementById('cancelBtn').style.display = 'inline-block';

            const editorArea = document.getElementById('editorArea');
            editorArea.innerHTML = `
                <div class="toolbar">
                    <button onclick="insertFormat('h1')">제목 1</button>
                    <button onclick="insertFormat('h2')">제목 2</button>
                    <button onclick="insertFormat('h3')">제목 3</button>
                    <button onclick="insertFormat('hr')">구분선</button>
                    <button onclick="insertFormat('table')">표 삽입</button>
                    <button onclick="insertFormat('bold')">굵게</button>
                    <button onclick="insertFormat('italic')">기울임</button>
                    <button onclick="document.getElementById('imageInput').click()" style="background: #FF9800; color: white;">🖼️ 이미지</button>
                    <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="insertImage(this)">
                </div>
                <div id="editorWrapper" style="position: relative;">
                    <div id="contentEditor" contenteditable="true" class="content-editor-editable">${data.content || '<p>내용을 입력하세요...</p>'}</div>
                    <div id="dropOverlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(76, 175, 80, 0.1); border: 3px dashed #4CAF50; border-radius: 5px; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                        <div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                            <h3 style="color: #4CAF50; margin: 0;">🖼️ 이미지를 여기에 드롭하세요</h3>
                        </div>
                    </div>
                </div>
                ${renderAttachments(data.attachments || [], true)}
            `;

            // 드래그 앤 드롭 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정
        function setupDragAndDrop() {
            const editor = document.getElementById('contentEditor');
            const overlay = document.getElementById('dropOverlay');
            let dragCounter = 0;

            editor.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter++;
                if (overlay) {
                    overlay.style.display = 'flex';
                }
            });

            editor.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter--;
                if (dragCounter === 0 && overlay) {
                    overlay.style.display = 'none';
                }
            });

            editor.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            editor.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragCounter = 0;
                if (overlay) {
                    overlay.style.display = 'none';
                }

                const files = e.dataTransfer.files;
                if (files.length === 0) return;

                // 이미지 파일만 필터링
                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                
                if (imageFiles.length === 0) {
                    showMessage('이미지 파일만 드롭할 수 있습니다.', true);
                    return;
                }

                // 각 이미지 업로드 및 삽입
                for (const file of imageFiles) {
                    await uploadAndInsertImageAtCursor(file);
                }
            });
        }

        // 커서 위치에 이미지 삽입
        async function uploadAndInsertImageAtCursor(file) {
            showMessage('이미지를 업로드 중입니다...');

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    const editor = document.getElementById('contentEditor');
                    const imageHTML = `<br><br><img src="${result.path}" alt="${result.originalname}" style="width: 80%; height: auto; margin: 20px auto; display: block;"><br><br>`;
                    
                    if (editor.contentEditable === 'true') {
                        // contenteditable의 경우 현재 커서 위치에 삽입
                        editor.focus();
                        document.execCommand('insertHTML', false, imageHTML);
                    } else {
                        // textarea의 경우 (하위 호환성)
                        const cursorPos = editor.selectionStart;
                        editor.value = editor.value.substring(0, cursorPos) + imageHTML + editor.value.substring(cursorPos);
                        editor.focus();
                        editor.selectionStart = editor.selectionEnd = cursorPos + imageHTML.length;
                    }
                    
                    showMessage('이미지가 삽입되었습니다.');
                    return true;
                } else {
                    showMessage('이미지 업로드에 실패했습니다.', true);
                    return false;
                }
            } catch (error) {
                console.error('이미지 업로드 실패:', error);
                showMessage('이미지 업로드에 실패했습니다.', true);
                return false;
            }
        }

        // 이미지 업로드 및 삽입 (공통 함수)
        async function uploadAndInsertImage(file, cursorPos) {
            showMessage('이미지를 업로드 중입니다...');

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    const editor = document.getElementById('contentEditor');
                    // 줄바꿈 2개씩 추가하여 이미지 앞뒤로 여백 생성, 가로 80%로 설정
                    const imageTag = `<br><br><img src="${result.path}" alt="${result.originalname}" style="width: 80%; height: auto; margin: 20px auto; display: block;"><br><br>`;
                    
                    // contenteditable div인 경우
                    if (editor.contentEditable === 'true') {
                        const imgElement = document.createElement('div');
                        imgElement.innerHTML = imageTag;
                        
                        // 현재 선택 영역에 삽입
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.deleteContents();
                            range.insertNode(imgElement.firstChild);
                        }
                    } else {
                        // textarea인 경우 (하위 호환성)
                        editor.value = editor.value.substring(0, cursorPos) + imageTag + editor.value.substring(cursorPos);
                        editor.focus();
                        editor.selectionStart = editor.selectionEnd = cursorPos + imageTag.length;
                    }
                    
                    showMessage('이미지가 삽입되었습니다.');
                    return true;
                } else {
                    showMessage('이미지 업로드에 실패했습니다.', true);
                    return false;
                }
            } catch (error) {
                console.error('이미지 업로드 실패:', error);
                showMessage('이미지 업로드에 실패했습니다.', true);
                return false;
            }
        }

        // 서식 삽입
        function insertFormat(type) {
            const editor = document.getElementById('contentEditor');
            
            // contenteditable div인 경우
            if (editor.contentEditable === 'true') {
                editor.focus();
                
                switch(type) {
                    case 'h1':
                        document.execCommand('formatBlock', false, '<h1>');
                        break;
                    case 'h2':
                        document.execCommand('formatBlock', false, '<h2>');
                        break;
                    case 'h3':
                        document.execCommand('formatBlock', false, '<h3>');
                        break;
                    case 'hr':
                        document.execCommand('insertHTML', false, '<hr>');
                        break;
                    case 'table':
                        const tableHTML = `<table>
    <tr>
        <th>헤더1</th>
        <th>헤더2</th>
        <th>헤더3</th>
    </tr>
    <tr>
        <td>데이터1</td>
        <td>데이터2</td>
        <td>데이터3</td>
    </tr>
</table><br>`;
                        document.execCommand('insertHTML', false, tableHTML);
                        break;
                    case 'bold':
                        document.execCommand('bold', false, null);
                        break;
                    case 'italic':
                        document.execCommand('italic', false, null);
                        break;
                }
            } else {
                // textarea인 경우 (하위 호환성)
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const selectedText = editor.value.substring(start, end);
                let insertText = '';

                switch(type) {
                    case 'h1':
                        insertText = `<h1>${selectedText || '제목을 입력하세요'}</h1>\n`;
                        break;
                    case 'h2':
                        insertText = `<h2>${selectedText || '제목을 입력하세요'}</h2>\n`;
                        break;
                    case 'h3':
                        insertText = `<h3>${selectedText || '제목을 입력하세요'}</h3>\n`;
                        break;
                    case 'hr':
                        insertText = '<hr>\n';
                        break;
                    case 'table':
                        insertText = `<table>
    <tr>
        <th>헤더1</th>
        <th>헤더2</th>
        <th>헤더3</th>
    </tr>
    <tr>
        <td>데이터1</td>
        <td>데이터2</td>
        <td>데이터3</td>
    </tr>
</table>\n`;
                        break;
                    case 'bold':
                        insertText = `<strong>${selectedText || '굵게'}</strong>`;
                        break;
                    case 'italic':
                        insertText = `<em>${selectedText || '기울임'}</em>`;
                        break;
                }

                editor.value = editor.value.substring(0, start) + insertText + editor.value.substring(end);
                editor.focus();
            }
        }

        // 첨부파일 렌더링
        function renderAttachments(attachments, editMode) {
            if (!attachments || attachments.length === 0) {
                if (!editMode) return '';
            }

            let html = '<div class="attachments"><h3>📎 첨부파일</h3>';
            
            if (attachments.length > 0) {
                html += '<ul class="attachment-list">';
                attachments.forEach((file, index) => {
                    html += `
                        <li class="attachment-item">
                            <a href="${file.path}" target="_blank">${file.originalname}</a>
                            ${editMode ? `<button class="btn btn-danger" onclick="removeAttachment(${index})">삭제</button>` : ''}
                        </li>
                    `;
                });
                html += '</ul>';
            }

            if (editMode) {
                html += `
                    <div class="file-upload-area" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" onchange="uploadFile(this)" multiple>
                        <p>📁 파일을 선택하거나 여기에 드롭하세요</p>
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

        // 이미지 삽입 (버튼 클릭)
        async function insertImage(input) {
            if (!input.files || input.files.length === 0) return;

            const file = input.files[0];
            
            // 이미지 파일인지 확인
            if (!file.type.startsWith('image/')) {
                showMessage('이미지 파일만 삽입할 수 있습니다.', true);
                input.value = '';
                return;
            }

            await uploadAndInsertImageAtCursor(file);
            input.value = '';
        }

        // 파일 업로드 (첨부파일용)
        async function uploadFile(input) {
            if (!input.files || input.files.length === 0) return;

            const formData = new FormData();
            formData.append('file', input.files[0]);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    showMessage('파일이 업로드되었습니다.');
                    
                    // 현재 챕터 데이터에 첨부파일 추가
                    const data = await fetch(`/api/chapters/${currentChapterId}`).then(r => r.json());
                    if (!data.attachments) data.attachments = [];
                    data.attachments.push({
                        filename: result.filename,
                        originalname: result.originalname,
                        path: result.path
                    });

                    // UI 업데이트
                    enterEditMode(data);
                } else {
                    showMessage('파일 업로드에 실패했습니다.', true);
                }
            } catch (error) {
                console.error('파일 업로드 실패:', error);
                showMessage('파일 업로드에 실패했습니다.', true);
            }

            input.value = '';
        }

        // 첨부파일 삭제
        function removeAttachment(index) {
            if (!confirm('이 파일을 삭제하시겠습니까?')) return;

            // 현재 데이터에서 첨부파일 제거
            fetch(`/api/chapters/${currentChapterId}`)
                .then(r => r.json())
                .then(data => {
                    data.attachments.splice(index, 1);
                    enterEditMode(data);
                    showMessage('파일이 삭제되었습니다.');
                });
        }

        // 저장
        async function saveContent() {
            const editor = document.getElementById('contentEditor');
            // contenteditable div인 경우 innerHTML, textarea인 경우 value 사용
            const content = editor.contentEditable === 'true' ? editor.innerHTML : editor.value;
            
            const response = await fetch(`/api/chapters/${currentChapterId}`);
            const currentData = await response.json();

            try {
                const saveResponse = await fetch(`/api/chapters/${currentChapterId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: content,
                        attachments: currentData.attachments || []
                    })
                });

                const result = await saveResponse.json();
                
                if (result.success) {
                    showMessage('저장되었습니다.');
                    await loadChapterData();
                    renderChapterTree();
                    await loadChapterContent(currentChapterId);
                } else {
                    showMessage('저장에 실패했습니다.', true);
                }
            } catch (error) {
                console.error('저장 실패:', error);
                showMessage('저장에 실패했습니다.', true);
            }
        }

        // 취소
        function cancelEdit() {
            if (confirm('변경사항을 취소하시겠습니까?')) {
                loadChapterContent(currentChapterId);
            }
        }

        // 메시지 표시
        function showMessage(message, isError = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'status-message' + (isError ? ' error' : '');
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        // 가이드 패널 표시
        function showGuidePanel() {
            document.getElementById('guidePanel').classList.add('active');
        }

        // 가이드 생성
        async function generateGuide(chapterId, existingContent = '') {
            const guideContent = document.getElementById('guideContent');
            guideContent.innerHTML = '<div class="guide-loading">AI가 글쓰기 가이드를 생성하고 있습니다</div>';

            try {
                const title = getChapterTitle(chapterId);
                const bookContext = `
도서 제목: 자유의지 예측
도서 주제: 명리 이론에 대한 새로운 접근 방법 (역사주)
타겟 독자: 45-60세, 25-30세 독자
문체: 전문성과 진중함을 유지하면서도 이해하기 쉬운 비문학 스타일
`;

                // 전체 목차를 읽기 쉬운 텍스트로 변환
                const tocText = generateTableOfContentsText();

                const response = await fetch('/api/generate-guide', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: title,
                        existingContent: existingContent,
                        bookContext: bookContext,
                        tableOfContents: tocText,
                        currentChapterId: chapterId
                    })
                });

                const data = await response.json();
                
                if (data.success && data.guide) {
                    guideContent.innerHTML = data.guide;
                } else {
                    guideContent.innerHTML = `<p style="color: #f44336;">가이드 생성에 실패했습니다.</p>
                    <p style="font-size: 12px; color: #999; margin-top: 10px;">
                        ※ AI 가이드 기능을 사용하려면 Anthropic API 키가 필요합니다.<br>
                        서버 실행 시 환경변수 ANTHROPIC_API_KEY를 설정해주세요.<br>
                        자세한 내용은 API_KEY_SETUP.md 파일을 참고하세요.
                    </p>`;
                }
            } catch (error) {
                console.error('가이드 생성 실패:', error);
                guideContent.innerHTML = `<p style="color: #f44336;">가이드 생성 중 오류가 발생했습니다.</p>
                <p style="font-size: 12px; color: #999; margin-top: 10px;">
                    서버 연결을 확인해주세요.
                </p>`;
            }
        }

        // 전체 목차를 텍스트로 변환
        function generateTableOfContentsText() {
            let text = '';
            
            Object.keys(tableOfContents).forEach(key => {
                const chapter = tableOfContents[key];
                text += `\n${chapter.title}\n`;
                
                if (chapter.children) {
                    Object.keys(chapter.children).forEach(subKey => {
                        const subChapter = chapter.children[subKey];
                        text += `  - ${subChapter.title}\n`;
                        
                        if (subChapter.children) {
                            Object.keys(subChapter.children).forEach(subSubKey => {
                                const subSubChapter = subChapter.children[subSubKey];
                                text += `    • ${subSubChapter.title}\n`;
                            });
                        }
                    });
                }
            });
            
            return text;
        }

        // 재가이드 생성
        async function regenerateGuide() {
            if (!currentChapterId) {
                showMessage('챕터를 먼저 선택해주세요.', true);
                return;
            }

            const editor = document.getElementById('contentEditor');
            let currentContent = '';
            
            if (editor) {
                // 편집 모드인 경우
                currentContent = editor.contentEditable === 'true' ? editor.innerHTML : editor.value;
            } else {
                // 뷰 모드인 경우 - 저장된 내용 가져오기
                try {
                    const response = await fetch(`/api/chapters/${currentChapterId}`);
                    const data = await response.json();
                    currentContent = data.content || '';
                } catch (error) {
                    console.error('내용 로드 실패:', error);
                }
            }

            // HTML 태그 제거하여 순수 텍스트만 추출 (분석용)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentContent;
            const textContent = tempDiv.textContent || tempDiv.innerText || '';

            // 내용이 있든 없든 가이드 생성
            // 내용이 있으면: 내용 분석 + 보충/수정 제안
            // 내용이 없으면: 목차 기반 작성 가이드
            if (textContent.trim().length > 0) {
                showMessage('작성된 내용을 분석하여 재가이드를 생성하고 있습니다...');
            } else {
                showMessage('챕터 제목과 목차를 기반으로 가이드를 생성하고 있습니다...');
            }
            
            await generateGuide(currentChapterId, textContent.trim());
        }

        // 버튼 이벤트 리스너
        document.getElementById('editBtn').addEventListener('click', async () => {
            const response = await fetch(`/api/chapters/${currentChapterId}`);
            const data = await response.json();
            enterEditMode(data);
        });

        document.getElementById('saveBtn').addEventListener('click', saveContent);
        document.getElementById('cancelBtn').addEventListener('click', cancelEdit);
    </script>
</body>
    <!-- 제목 편집 통합 - 모든 함수 정의 후 로드 -->\r\n    <script src="title-integration.js"></script>
</html>
